<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document source="/home/fbaumanis/openstack/soc8_test/openstack_repo/neutron/doc/source/contributor/internals/objects_usage.rst">
    <comment xml:space="preserve">Licensed under the Apache License, Version 2.0 (the "License"); you may
not use this file except in compliance with the License. You may obtain
a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations
under the License.


Convention for heading levels in neutron devref:
=======  Heading 0 (reserved for the title in a document)
-------  Heading 1
~~~~~~~  Heading 2
+++++++  Heading 3
'''''''  Heading 4
(Avoid deeper levels because they do not render well.)</comment>
    <section ids="objects-in-neutron" names="objects\ in\ neutron">
        <title>Objects in neutron</title>
        <paragraph>Object versioning is a key concept in achieving rolling upgrades. Since its
            initial implementation by the nova community, a versioned object model has been
            pushed to an oslo library so that its benefits can be shared across projects.</paragraph>
        <paragraph><reference name="Oslo VersionedObjects" refuri="https://docs.openstack.org/oslo.versionedobjects/latest/">Oslo VersionedObjects</reference> (aka OVO) is a database facade, where you define the
            middle layer between software and the database schema. In this layer, a
            versioned object per database resource is created with a strict data definition
            and version number. With OVO, when you change the database schema, the version
            of the object also changes and a backward compatible translation is provided.
            This allows different versions of software to communicate with one another (via
            RPC).</paragraph>
        <paragraph>OVO is also commonly used for RPC payload versioning. OVO creates versioned
            dictionary messages by defining a strict structure and keeping strong typing.
            Because of it, you can be sure of what is sent and how to use the data on the
            receiving end.</paragraph>
        <target ids="oslo-versionedobjects" names="oslo\ versionedobjects" refuri="https://docs.openstack.org/oslo.versionedobjects/latest/"></target>
        <section ids="usage-of-objects" names="usage\ of\ objects">
            <title>Usage of objects</title>
            <section ids="crud-operations" names="crud\ operations">
                <title>CRUD operations</title>
                <paragraph>Objects support CRUD operations: <literal classes="code">create()</literal>, <literal classes="code">get_object()</literal> and
                    <literal classes="code">get_objects()</literal> (equivalent of <literal classes="code">read</literal>), <literal classes="code">update()</literal>,
                    <literal classes="code">delete()</literal>, <literal classes="code">update_objects()</literal>, and <literal classes="code">delete_objects()</literal>. The
                    nature of OVO is, when any change is applied, OVO tracks it. After calling
                    <literal classes="code">create()</literal> or <literal classes="code">update()</literal>, OVO detects this and changed fields are
                    saved in the database. Please take a look at simple object usage scenarios
                    using example of DNSNameServer:</paragraph>
                <literal_block highlight_args="{}" language="Python" linenos="False" xml:space="preserve"># to create an object, you can pass the attributes in constructor:
dns = DNSNameServer(context, address='asd', subnet_id='xxx', order=1)
dns.create()

# or you can create a dict and pass it as kwargs:
dns_data = {'address': 'asd', 'subnet_id': 'xxx', 'order': 1}
dns = DNSNameServer(context, **dns_data)
dns.create()

# for fetching multiple objects:
dnses = DNSNameServer.get_objects(context)
# will return list of all dns name servers from DB

# for fetching objects with substrings in a string field:
from neutron.objects import utils as obj_utils
dnses = DNSNameServer.get_objects(context, address=obj_utils.StringMatchingContains('10.0.0'))
# will return list of all dns name servers from DB that has '10.0.0' in their addresses

# to update fields:
dns = DNSNameServer.get_object(context, address='asd', subnet_id='xxx')
dns.order = 2
dns.update()

# if you don't care about keeping the object, you can execute the update
# without fetch of the object state from the underlying persistent layer
count = DNSNameServer.update_objects(
    context, {'order': 3}, address='asd', subnet_id='xxx')

# to remove object with filter arguments:
filters = {'address': 'asd', 'subnet_id': 'xxx'}
DNSNameServer.delete_objects(context, **filters)</literal_block>
            </section>
            <section ids="filter-sort-and-paginate" names="filter,\ sort\ and\ paginate">
                <title>Filter, sort and paginate</title>
                <paragraph>The <literal classes="code">NeutronDbObject</literal> class has strict validation on which field sorting
                    and filtering can happen. When calling <literal classes="code">get_objects()</literal>, <literal classes="code">count()</literal>,
                    <literal classes="code">update_objects()</literal>, <literal classes="code">delete_objects()</literal> and <literal classes="code">objects_exist()</literal>,
                    <literal classes="code">validate_filters()</literal> is invoked, to see if it’s a supported filter
                    criterion (which is by default non-synthetic fields only). Additional filters
                    can be defined using <literal classes="code">register_filter_hook_on_model()</literal>. This will add the
                    requested string to valid filter names in object implementation. It is
                    optional.</paragraph>
                <paragraph>In order to disable filter validation, <literal classes="code">validate_filters=False</literal> needs to
                    be passed as an argument in aforementioned methods. It was added because the
                    default behaviour of the neutron API is to accept everything at API level
                    and filter it out at DB layer. This can be used by out of tree extensions.</paragraph>
                <paragraph><literal classes="code">register_filter_hook_on_model()</literal> is a complementary implementation in
                    the <literal classes="code">NeutronDbObject</literal> layer to DB layer’s
                    <literal classes="code">register_model_query_hook()</literal>, which adds support for extra filtering
                    during construction of SQL query. When extension defines extra query hook, it
                    needs to be registered using the objects
                    <literal classes="code">register_filter_hook_on_model()</literal>, if it is not already included in the
                    objects <literal classes="code">fields</literal>.</paragraph>
                <paragraph>To limit or paginate results, <literal classes="code">Pager</literal> object can be used. It accepts
                    <literal classes="code">sorts</literal> (list of <literal classes="code">(key, direction)</literal> tuples), <literal classes="code">limit</literal>,
                    <literal classes="code">page_reverse</literal> and <literal classes="code">marker</literal> keywords.</paragraph>
                <literal_block highlight_args="{}" language="Python" linenos="False" xml:space="preserve"># filtering

# to get an object based on primary key filter
dns = DNSNameServer.get_object(context, address='asd', subnet_id='xxx')

# to get multiple objects
dnses = DNSNameServer.get_objects(context, subnet_id='xxx')

filters = {'subnet_id': ['xxx', 'yyy']}
dnses = DNSNameServer.get_objects(context, **filters)

# do not validate filters
dnses = DNSNameServer.get_objects(context, validate_filters=False,
                                  fake_filter='xxx')

# count the dns servers for given subnet
dns_count = DNSNameServer.count(context, subnet_id='xxx')

# sorting
# direction True == ASC, False == DESC
direction = False
pager = Pager(sorts=[('order', direction)])
dnses = DNSNameServer.get_objects(context, _pager=pager, subnet_id='xxx')</literal_block>
            </section>
        </section>
        <section ids="defining-your-own-object" names="defining\ your\ own\ object">
            <title>Defining your own object</title>
            <paragraph>In order to add a new object in neutron, you have to:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Create an object derived from <literal classes="code">NeutronDbObject</literal> (aka base object)</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Add/reuse data model</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Define fields</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>It is mandatory to define data model using <literal classes="code">db_model</literal> attribute from
                <literal classes="code">NeutronDbObject</literal>.</paragraph>
            <paragraph>Fields should be defined using <literal classes="code">oslo_versionobjects.fields</literal> exposed
                types. If there is a special need to create a new type of field, you can use
                <literal classes="code">common_types.py</literal> in the <literal classes="code">neutron.objects</literal> directory.
                Example:</paragraph>
            <literal_block xml:space="preserve">fields = {
    'id': common_types.UUIDField(),
    'name': obj_fields.StringField(),
    'subnetpool_id': common_types.UUIDField(nullable=True),
    'ip_version': common_types.IPVersionEnumField()
}</literal_block>
            <paragraph><literal classes="code">VERSION</literal> is mandatory and defines the version of the object. Initially,
                set the <literal classes="code">VERSION</literal> field to 1.0.
                Change <literal classes="code">VERSION</literal> if fields or their types are modified. When you change
                the version of objects being exposed via RPC, add method
                <literal classes="code">obj_make_compatible(self, primitive, target_version)</literal>.</paragraph>
            <note>
                <paragraph>Standard Attributes are automatically added to OVO fields in base class.
                    Attributes <footnote_reference auto="1" ids="id1" refid="id8">1</footnote_reference> like <literal classes="code">description</literal>, <literal classes="code">created_at</literal>,
                    <literal classes="code">updated_at</literal> and <literal classes="code">revision_number</literal> are added in <footnote_reference auto="1" ids="id2" refid="id9">2</footnote_reference>.</paragraph>
            </note>
            <paragraph><literal classes="code">primary_keys</literal> is used to define the list of fields that uniquely
                identify the object. In case of database backed objects, it’s usually mapped
                onto SQL primary keys. For immutable object fields that cannot be changed,
                there is a <literal classes="code">fields_no_update</literal> list, that contains
                <literal classes="code">primary_keys</literal> by default.</paragraph>
            <paragraph>If there is a situation where a field needs to be named differently in an
                object than in the database schema, you can use
                <literal classes="code">fields_need_translation</literal>. This dictionary contains the name of the field
                in the object definition (the key) and the name of the field in the database
                (the value). This allows to have a different object layer representation for
                database persisted data.
                For example in IP allocation pools:</paragraph>
            <literal_block xml:space="preserve">fields_need_translation = {
    'start': 'first_ip',  # field_ovo: field_db
    'end': 'last_ip'
}</literal_block>
            <paragraph>The above dictionary is used in <literal classes="code">modify_fields_from_db()</literal> and in
                <literal classes="code">modify_fields_to_db()</literal> methods which are implemented in base class and
                will translate the software layer to database schema naming, and vice versa. It
                can also be used to rename <literal classes="code">orm.relationship</literal> backed object-type fields.</paragraph>
            <paragraph>Most object fields are usually directly mapped to database model attributes.
                Sometimes it’s useful to expose attributes that are not defined in the model
                table itself, like relationships and such. In this case,
                <literal classes="code">synthetic_fields</literal> may become handy. This object property can define a
                list of object fields that don’t belong to the object database model and that
                are hence instead to be implemented in some custom way. Some of those fields
                map to <literal classes="code">orm.relationships</literal> defined on models, while others are completely
                untangled from the database layer.</paragraph>
            <paragraph>When exposing existing <literal classes="code">orm.relationships</literal> as an ObjectField-typed field,
                you can use the <literal classes="code">foreign_keys</literal> object property that defines a link
                between two object types. When used, it allows objects framework to
                automatically instantiate child objects, and fill the relevant parent fields,
                based on <literal classes="code">orm.relationships</literal> defined on parent models. In order to
                automatically populate the <literal classes="code">synthetic_fields</literal>, the <literal classes="code">foreign_keys</literal>
                property is introduced. <literal classes="code">load_synthetic_db_fields()</literal> <footnote_reference auto="1" ids="id3" refid="id10">3</footnote_reference> method from
                NeutronDbObject uses <literal classes="code">foreign_keys</literal> to match the foreign key in related
                object and local field that the foreign key is referring to. See simplified
                examples:</paragraph>
            <literal_block highlight_args="{}" language="Python" linenos="False" xml:space="preserve">class DNSNameServerSqlModel(model_base.BASEV2):
    address = sa.Column(sa.String(128), nullable=False, primary_key=True)
    subnet_id = sa.Column(sa.String(36),
                          sa.ForeignKey('subnets.id', ondelete="CASCADE"),
                          primary_key=True)

class SubnetSqlModel(model_base.BASEV2, HasId, HasProject):
    name = sa.Column(sa.String(attr.NAME_MAX_LEN))
    allocation_pools = orm.relationship(IPAllocationPoolSqlModel)
    dns_nameservers = orm.relationship(DNSNameServerSqlModel,
                                       backref='subnet',
                                       cascade='all, delete, delete-orphan',
                                       lazy='subquery')

class IPAllocationPoolSqlModel(model_base.BASEV2, HasId):
    subnet_id = sa.Column(sa.String(36), sa.ForeignKey('subnets.id'))

@obj_base.VersionedObjectRegistry.register
class DNSNameServerOVO(base.NeutronDbObject):
    VERSION = '1.0'
    db_model = DNSNameServerSqlModel

    # Created based on primary_key=True in model definition.
    # The object is uniquely identified by the pair of address and
    # subnet_id fields. Override the default 'id' 1-tuple.
    primary_keys = ['address', 'subnet_id']

    # Allow to link DNSNameServerOVO child objects into SubnetOVO parent
    # object fields via subnet_id child database model attribute.
    # Used during loading synthetic fields in SubnetOVO get_objects.
    foreign_keys = {'SubnetOVO': {'subnet_id': 'id'}}

    fields = {
        'address': obj_fields.StringField(),
        'subnet_id': common_types.UUIDField(),
    }

@obj_base.VersionedObjectRegistry.register
class SubnetOVO(base.NeutronDbObject):
    VERSION = '1.0'
    db_model =  SubnetSqlModel

    fields = {
        'id': common_types.UUIDField(),  # HasId from model class
        'project_id': obj_fields.StringField(nullable=True),  # HasProject from model class
        'subnet_name': obj_fields.StringField(nullable=True),
        'dns_nameservers': obj_fields.ListOfObjectsField('DNSNameServer',
                                                         nullable=True),
        'allocation_pools': obj_fields.ListOfObjectsField('IPAllocationPoolOVO',
                                                          nullable=True)
    }

    # Claim dns_nameservers field as not directly mapped into the object
    # database model table.
    synthetic_fields = ['allocation_pools', 'dns_nameservers']

    # Rename in-database subnet_name attribute into name object field
    fields_need_translation = {
        'name': 'subnet_name'
    }


@obj_base.VersionedObjectRegistry.register
class IPAllocationPoolOVO(base.NeutronDbObject):
    VERSION = '1.0'
    db_model = IPAllocationPoolSqlModel

    fields = {
        'subnet_id': common_types.UUIDField()
    }

    foreign_keys = {'SubnetOVO': {'subnet_id': 'id'}}</literal_block>
            <paragraph>The <literal classes="code">foreign_keys</literal> is used in <literal classes="code">SubnetOVO</literal> to populate the
                <literal classes="code">allocation_pools</literal> <footnote_reference auto="1" ids="id4" refid="id11">4</footnote_reference> synthetic field using the
                <literal classes="code">IPAllocationPoolOVO</literal> class. Single object type may be linked to multiple
                parent object types, hence <literal classes="code">foreign_keys</literal> property may have multiple keys
                in the dictionary.</paragraph>
            <note>
                <paragraph><literal classes="code">foreign_keys</literal> is declared in related object
                    <literal classes="code">IPAllocationPoolOVO</literal>, the same way as it’s done in the SQL model
                    <literal classes="code">IPAllocationPoolSqlModel</literal>: <literal classes="code">sa.ForeignKey('subnets.id')</literal></paragraph>
            </note>
            <note>
                <paragraph>Only single foreign key is allowed (usually parent ID), you cannot link
                    through multiple model attributes.</paragraph>
            </note>
            <paragraph>It is important to remember about the nullable parameter. In the SQLAlchemy
                model, the nullable parameter is by default <literal classes="code">True</literal>, while for OVO fields,
                the nullable is set to <literal classes="code">False</literal>. Make sure you correctly map database
                column nullability properties to relevant object fields.</paragraph>
        </section>
        <section ids="synthetic-fields" names="synthetic\ fields">
            <title>Synthetic fields</title>
            <paragraph><literal classes="code">synthetic_fields</literal> is a list of fields, that are not directly backed by
                corresponding object SQL table attributes. Synthetic fields are not limited in
                types that can be used to implement them.</paragraph>
            <literal_block highlight_args="{}" language="Python" linenos="False" xml:space="preserve">fields = {
    'dhcp_agents': obj_fields.ObjectField('NetworkDhcpAgentBinding',
                                          nullable=True), # field that contains another single NeutronDbObject of NetworkDhcpAgentBinding type
    'shared': obj_fields.BooleanField(default=False),
    'subnets': obj_fields.ListOfObjectsField('Subnet', nullable=True)
}

# All three fields do not belong to corresponding SQL table, and will be
# implemented in some object-specific way.
synthetic_fields = ['dhcp_agents', 'shared', 'subnets']</literal_block>
            <paragraph><literal classes="code">ObjectField</literal> and <literal classes="code">ListOfObjectsField</literal>  take the name of object class
                as an argument.</paragraph>
            <section ids="implementing-custom-synthetic-fields" names="implementing\ custom\ synthetic\ fields">
                <title>Implementing custom synthetic fields</title>
                <paragraph>Sometimes you may want to expose a field on an object that is not mapped into a
                    corresponding database model attribute, or its <literal classes="code">orm.relationship</literal>; or may
                    want to expose a <literal classes="code">orm.relationship</literal> data in a format that is not directly
                    mapped onto a child object type. In this case, here is what you need to do to
                    implement custom getters and setters for the custom field.
                    The custom method to load the synthetic fields can be helpful if the field is
                    not directly defined in the database, OVO class is not suitable to load the
                    data or the related object contains only the ID and property of the parent
                    object, for example <literal classes="code">subnet_id</literal> and property of it: <literal classes="code">is_external</literal>.</paragraph>
                <paragraph>In order to implement the custom method to load the synthetic field, you need
                    to provide loading method in the OVO class and override the base class method
                    <literal classes="code">from_db_object()</literal> and <literal classes="code">obj_load_attr()</literal>. The first one is
                    responsible for loading the fields to object attributes when calling
                    <literal classes="code">get_object()</literal> and <literal classes="code">get_objects()</literal>, <literal classes="code">create()</literal> and
                    <literal classes="code">update()</literal>. The second is responsible for loading attribute when it is
                    not set in object. Also, when you need to create related object with attributes
                    passed in constructor, <literal classes="code">create()</literal> and <literal classes="code">update()</literal> methods need to be
                    overwritten. Additionally <literal classes="code">is_external</literal> attribute can be exposed as a
                    boolean, instead of as an object-typed field. When field is changed, but it
                    doesn’t need to be saved into database, <literal classes="code">obj_reset_changes()</literal> can be
                    called, to tell OVO library to ignore that. Let’s see an example:</paragraph>
                <literal_block highlight_args="{}" language="Python" linenos="False" xml:space="preserve">@obj_base.VersionedObjectRegistry.register
class ExternalSubnet(base.NeutronDbObject):
    VERSION = '1.0'
    fields = {'subnet_id': common_types.UUIDField(),
              'is_external': obj_fields.BooleanField()}
    primary_keys = ['subnet_id']
    foreign_keys = {'Subnet': {'subnet_id': 'id'}}


@obj_base.VersionedObjectRegistry.register
class Subnet(base.NeutronDbObject):
    VERSION = '1.0'
    fields = {'external': obj_fields.BooleanField(nullable=True),}
    synthetic_fields = ['external']

    # support new custom 'external=' filter for get_objects family of
    # objects API
    def __init__(self, context=None, **kwargs):
        super(Subnet, self).__init__(context, **kwargs)
        self.add_extra_filter_name('external')

    def create(self):
        fields = self.get_changes()
        with db_api.context_manager.writer.using(context):
            if 'external' in fields:
                ExternalSubnet(context, subnet_id=self.id,
                    is_external=fields['external']).create()
            # Call to super() to create the SQL record for the object, and
            # reload its fields from the database, if needed.
            super(Subnet, self).create()

    def update(self):
        fields = self.get_changes()
        with db_api.context_manager.writer.using(context):
            if 'external' in fields:
                # delete the old ExternalSubnet record, if present
                obj_db_api.delete_objects(
                    self.obj_context, ExternalSubnet.db_model,
                    subnet_id=self.id)
                # create the new intended ExternalSubnet object
                ExternalSubnet(context, subnet_id=self.id,
                    is_external=fields['external']).create()
            # calling super().update() will reload the synthetic fields
            # and also will update any changed non-synthetic fields, if any
            super(Subnet, self).update()

    # this method is called when user of an object accesses the attribute
    # and requested attribute is not set.
    def obj_load_attr(self, attrname):
        if attrname == 'external':
            return self._load_external()
        # it is important to call super if attrname does not match
        # because the base implementation is handling the nullable case
        super(Subnet, self).obj_load_attr(attrname)

    def _load_external(self, db_obj=None):
        # do the loading here
        if db_obj:
            # use DB model to fetch the data that may be side-loaded
            external = db_obj.external.is_external if db_obj.external else None
        else:
            # perform extra operation to fetch the data from DB
            external_obj = ExternalSubnet.get_object(context,
                subnet_id=self.id)
            external = external_obj.is_external if external_obj else None

        # it is important to set the attribute and call obj_reset_changes
        setattr(self, 'external', external)
        self.obj_reset_changes(['external'])

    # this is defined in NeutronDbObject and is invoked during get_object(s)
    # and create/update.
    def from_db_object(self, obj):
        super(Subnet, self).from_db_object(obj)
        self._load_external(obj)</literal_block>
                <paragraph>In the above example, the <literal classes="code">get_object(s)</literal> methods do not have to be
                    overwritten, because <literal classes="code">from_db_object()</literal> takes care of loading the
                    synthetic fields in custom way.</paragraph>
            </section>
        </section>
        <section ids="standard-attributes" names="standard\ attributes">
            <title>Standard attributes</title>
            <paragraph>The standard attributes are added automatically in metaclass
                <literal classes="code">DeclarativeObject</literal>. If adding standard attribute, it has to be added in
                <literal>neutron/objects/extensions/standardattributes.py</literal>. It will be added
                to all relevant objects that use the <literal classes="code">standardattributes</literal> model.
                Be careful when adding something to the above, because it could trigger a
                change in the object’s <literal classes="code">VERSION</literal>.
                For more on how standard attributes work, check <footnote_reference auto="1" ids="id5" refid="id12">5</footnote_reference>.</paragraph>
        </section>
        <section ids="rbac-handling-in-objects" names="rbac\ handling\ in\ objects">
            <title>RBAC handling in objects</title>
            <paragraph>The RBAC is implemented currently for resources like: Subnet(*), Network and
                QosPolicy. Subnet is a special case, because access control of Subnet depends
                on Network RBAC entries.</paragraph>
            <paragraph>The RBAC support for objects is defined in <literal>neutron/objects/rbac_db.py</literal>. It
                defines new base class <literal classes="code">NeutronRbacObject</literal>. The new class wraps standard
                <literal classes="code">NeutronDbObject</literal> methods like <literal classes="code">create()</literal>, <literal classes="code">update()</literal> and
                <literal classes="code">to_dict()</literal>. It checks if the <literal classes="code">shared</literal> attribute is defined in the
                <literal classes="code">fields</literal> dictionary and adds it to <literal classes="code">synthetic_fields</literal>. Also,
                <literal classes="code">rbac_db_model</literal> is required to be defined in Network and QosPolicy
                classes.</paragraph>
            <paragraph><literal classes="code">NeutronRbacObject</literal> is a common place to handle all operations on the
                RBAC entries, like getting the info if resource is shared or not, creation and
                updates of them. By wrapping the <literal classes="code">NeutronDbObject</literal> methods, it is
                manipulating the ‘shared’ attribute while <literal classes="code">create()</literal> and <literal classes="code">update()</literal>
                methods are called.</paragraph>
            <paragraph>The example of defining the Network OVO:</paragraph>
            <literal_block highlight_args="{}" language="Python" linenos="False" xml:space="preserve">class Network(standard_attr.HasStandardAttributes, model_base.BASEV2,
          model_base.HasId, model_base.HasProject):
    """Represents a v2 neutron network."""
    name = sa.Column(sa.String(attr.NAME_MAX_LEN))
    rbac_entries = orm.relationship(rbac_db_models.NetworkRBAC,
                                    backref='network', lazy='joined',
                                    cascade='all, delete, delete-orphan')


# Note the base class for Network OVO:
@obj_base.VersionedObjectRegistry.register
class Network(rbac_db.NeutronRbacObject):
    # Version 1.0: Initial version
    VERSION = '1.0'

    # rbac_db_model is required to be added here
    rbac_db_model = rbac_db_models.NetworkRBAC
    db_model = models_v2.Network

    fields = {
        'id': common_types.UUIDField(),
        'project_id': obj_fields.StringField(nullable=True),
        'name': obj_fields.StringField(nullable=True),
        # share is required to be added to fields
        'shared': obj_fields.BooleanField(default=False),
    }</literal_block>
            <note>
                <paragraph>The <literal classes="code">shared</literal> field is not added to the <literal classes="code">synthetic_fields</literal>,
                    because <literal classes="code">NeutronRbacObject</literal> requires to add it by itself, otherwise
                    <literal classes="code">ObjectActionError</literal> is raised. <footnote_reference auto="1" ids="id6" refid="id13">6</footnote_reference></paragraph>
            </note>
        </section>
        <section ids="extensions-to-neutron-resources" names="extensions\ to\ neutron\ resources">
            <title>Extensions to neutron resources</title>
            <paragraph>One of the methods to extend neutron resources is to add an arbitrary value to
                dictionary representing the data by providing
                <literal classes="code">extend_(subnet|port|network)_dict()</literal> function and defining loading
                method.</paragraph>
            <paragraph>From DB perspective, all the data will be loaded, including all declared fields
                from DB relationships. Current implementation for core resources (Port, Subnet,
                Network etc.) is that DB result is parsed by <literal classes="code">make_&lt;resource&gt;_dict()</literal> and
                <literal classes="code">extend_&lt;resource&gt;_dict()</literal>. When extension is enabled,
                <literal classes="code">extend_&lt;resource&gt;_dict()</literal> takes the DB results and declares new fields
                in resulting dict. When extension is not enabled, data will be fetched, but
                will not be populated into resulting dict, because
                <literal classes="code">extend_&lt;resource&gt;_dict()</literal> will not be called.</paragraph>
            <paragraph>Plugins can still use objects for some work, but then convert them to dicts and
                work as they please, extending the dict as they wish.</paragraph>
            <paragraph>For example:</paragraph>
            <literal_block highlight_args="{}" language="Python" linenos="False" xml:space="preserve">class TestSubnetExtension(model_base.BASEV2):
    subnet_id = sa.Column(sa.String(36),
                          sa.ForeignKey('subnets.id', ondelete="CASCADE"),
                          primary_key=True)
    value = sa.Column(sa.String(64))
    subnet = orm.relationship(
        models_v2.Subnet,
        # here is the definition of loading the extension with Subnet model:
        backref=orm.backref('extension', cascade='delete', uselist=False))


@oslo_obj_base.VersionedObjectRegistry.register_if(False)
class TestSubnetExtensionObject(obj_base.NeutronDbObject):
    # Version 1.0: Initial version
    VERSION = '1.0'

    db_model = TestSubnetExtension

    fields = {
        'subnet_id': common_types.UUIDField(),
        'value': obj_fields.StringField(nullable=True)
    }

    primary_keys = ['subnet_id']
    foreign_keys = {'Subnet': {'subnet_id': 'id'}}


@obj_base.VersionedObjectRegistry.register
class Subnet(base.NeutronDbObject):
    # Version 1.0: Initial version
    VERSION = '1.0'

    fields = {
        'id': common_types.UUIDField(),
        'extension': obj_fields.ObjectField(TestSubnetExtensionObject.__name__,
                                            nullable=True),
    }

    synthetic_fields = ['extension']


# when defining the extend_subnet_dict function:
def extend_subnet_dict(self, session, subnet_ovo, result):
    value = subnet_ovo.extension.value if subnet_ovo.extension else ''
    result['subnet_extension'] = value</literal_block>
            <paragraph>The above example is the ideal situation, where all extensions have objects
                adopted and enabled in core neutron resources.</paragraph>
            <paragraph>By introducing the OVO work in tree, interface between base plugin code and
                registered extension functions hasn’t been changed. Those still receive a
                SQLAlchemy model, not an object. This is achieved by capturing the
                corresponding database model on <literal classes="code">get_***/create/update</literal>, and exposing it
                via <literal classes="code">&lt;object&gt;.db_obj</literal></paragraph>
        </section>
        <section ids="backward-compatibility-for-tenant-id" names="backward\ compatibility\ for\ tenant_id">
            <title>Backward compatibility for tenant_id</title>
            <paragraph>All objects can support <literal classes="code">tenant_id</literal> and <literal classes="code">project_id</literal> filters and
                fields at the same time; it is automatically enabled for all objects that have
                a <literal classes="code">project_id</literal> field. The base <literal classes="code">NeutronDbObject</literal> class has support
                for exposing <literal classes="code">tenant_id</literal> in dictionary access to the object fields
                (<literal classes="code">subnet['tenant_id']</literal>) and in <literal classes="code">to_dict()</literal> method. There is a
                <literal classes="code">tenant_id</literal> read-only property for every object that has
                <literal classes="code">project_id</literal> in <literal classes="code">fields</literal>. It is not exposed in
                <literal classes="code">obj_to_primitive()</literal> method, so it means that <literal classes="code">tenant_id</literal> will not
                be sent over RPC callback wire. When talking about filtering/sorting by
                <literal classes="code">tenant_id</literal>, the filters should be converted to expose <literal classes="code">project_id</literal>
                field. This means that for the long run, the API layer should translate it, but
                as temporary workaround it can be done at DB layer before passing filters to
                objects <literal classes="code">get_objects()</literal> method, for example:</paragraph>
            <literal_block highlight_args="{}" language="Python" linenos="False" xml:space="preserve">def convert_filters(result):
    if 'tenant_id' in result:
        result['project_id'] = result.pop('tenant_id')
    return result

def get_subnets(context, filters):
    filters = convert_filters(**filters)
    return subnet_obj.Subnet.get_objects(context, **filters)</literal_block>
            <paragraph>The <literal classes="code">convert_filters</literal> method is available in
                <literal>neutron.objects.utils</literal> <footnote_reference auto="1" ids="id7" refid="id14">7</footnote_reference>.</paragraph>
        </section>
        <section ids="references" names="references">
            <title>References</title>
            <footnote auto="1" backrefs="id1" ids="id8" names="1">
                <label>1</label>
                <paragraph><reference refuri="https://git.openstack.org/cgit/openstack/neutron/tree/neutron/objects/base.py?h=stable/ocata#n258">https://git.openstack.org/cgit/openstack/neutron/tree/neutron/objects/base.py?h=stable/ocata#n258</reference></paragraph>
            </footnote>
            <footnote auto="1" backrefs="id2" ids="id9" names="2">
                <label>2</label>
                <paragraph><reference refuri="https://git.openstack.org/cgit/openstack/neutron/tree/neutron/db/standard_attr.py?h=stable/ocata">https://git.openstack.org/cgit/openstack/neutron/tree/neutron/db/standard_attr.py?h=stable/ocata</reference></paragraph>
            </footnote>
            <footnote auto="1" backrefs="id3" ids="id10" names="3">
                <label>3</label>
                <paragraph><reference refuri="https://git.openstack.org/cgit/openstack/neutron/tree/neutron/objects/base.py?h=stable/ocata#n516">https://git.openstack.org/cgit/openstack/neutron/tree/neutron/objects/base.py?h=stable/ocata#n516</reference></paragraph>
            </footnote>
            <footnote auto="1" backrefs="id4" ids="id11" names="4">
                <label>4</label>
                <paragraph><reference refuri="https://git.openstack.org/cgit/openstack/neutron/tree/neutron/objects/base.py?h=stable/ocata#n542">https://git.openstack.org/cgit/openstack/neutron/tree/neutron/objects/base.py?h=stable/ocata#n542</reference></paragraph>
            </footnote>
            <footnote auto="1" backrefs="id5" ids="id12" names="5">
                <label>5</label>
                <paragraph><reference refuri="https://docs.openstack.org/neutron/latest/contributor/internals/db_layer.html#the-standard-attribute-table">https://docs.openstack.org/neutron/latest/contributor/internals/db_layer.html#the-standard-attribute-table</reference></paragraph>
            </footnote>
            <footnote auto="1" backrefs="id6" ids="id13" names="6">
                <label>6</label>
                <paragraph><reference refuri="https://git.openstack.org/cgit/openstack/neutron/tree/neutron/objects/rbac_db.py?h=stable/ocata#n291">https://git.openstack.org/cgit/openstack/neutron/tree/neutron/objects/rbac_db.py?h=stable/ocata#n291</reference></paragraph>
            </footnote>
            <footnote auto="1" backrefs="id7" ids="id14" names="7">
                <label>7</label>
                <paragraph><reference refuri="https://git.openstack.org/cgit/openstack/neutron/tree/neutron/objects/utils.py?h=stable/ocata">https://git.openstack.org/cgit/openstack/neutron/tree/neutron/objects/utils.py?h=stable/ocata</reference></paragraph>
            </footnote>
        </section>
    </section>
</document>
