<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document source="/home/fbaumanis/openstack/soc8_test/openstack_repo/neutron/doc/source/contributor/internals/quality_of_service.rst">
    <comment xml:space="preserve">Licensed under the Apache License, Version 2.0 (the "License"); you may
not use this file except in compliance with the License. You may obtain
a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations
under the License.


Convention for heading levels in Neutron devref:
=======  Heading 0 (reserved for the title in a document)
-------  Heading 1
~~~~~~~  Heading 2
+++++++  Heading 3
'''''''  Heading 4
(Avoid deeper levels because they do not render well.)</comment>
    <section ids="quality-of-service" names="quality\ of\ service">
        <title>Quality of Service</title>
        <paragraph>Quality of Service advanced service is designed as a service plugin. The
            service is decoupled from the rest of Neutron code on multiple levels (see
            below).</paragraph>
        <paragraph>QoS extends core resources (ports, networks) without using mixins inherited
            from plugins but through an ml2 extension driver.</paragraph>
        <paragraph>Details about the DB models, API extension, and use cases can be found here: <reference name="qos spec" refuri="http://specs.openstack.org/openstack/neutron-specs/specs/liberty/qos-api-extension.html">qos spec</reference><target ids="qos-spec" names="qos\ spec" refuri="http://specs.openstack.org/openstack/neutron-specs/specs/liberty/qos-api-extension.html"></target>
            .</paragraph>
        <section ids="service-side-design" names="service\ side\ design">
            <title>Service side design</title>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>neutron.extensions.qos:
                        base extension + API controller definition. Note that rules are subattributes
                        of policies and hence embedded into their URIs.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>neutron.services.qos.qos_plugin:
                        QoSPlugin, service plugin that implements ‘qos’ extension, receiving and
                        handling API calls to create/modify policies and rules.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>neutron.services.qos.drivers.manager:
                        the manager that passes object actions down to every enabled QoS driver and
                        issues RPC calls when any of the drivers require RPC push notifications.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>neutron.services.qos.drivers.base:
                        the interface class for pluggable QoS drivers that are used to update
                        backends about new {create, update, delete} events on any rule or policy
                        change, including precommit events that some backends could need for
                        synchronization reason. The drivers also declare which QoS rules,
                        VIF drivers and VNIC types are supported.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>neutron.core_extensions.base:
                        Contains an interface class to implement core resource (port/network)
                        extensions. Core resource extensions are then easily integrated into
                        interested plugins. We may need to  have a core resource extension manager
                        that would utilize those extensions, to avoid plugin modifications for every
                        new core resource extension.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>neutron.core_extensions.qos:
                        Contains QoS core resource extension that conforms to the interface described
                        above.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>neutron.plugins.ml2.extensions.qos:
                        Contains ml2 extension driver that handles core resource updates by reusing
                        the core_extensions.qos module mentioned above. In the future, we would like
                        to see a plugin-agnostic core resource extension manager that could be
                        integrated into other plugins with ease.</paragraph>
                </list_item>
            </bullet_list>
            <section ids="qos-plugin-implementation-guide" names="qos\ plugin\ implementation\ guide">
                <title>QoS plugin implementation guide</title>
                <paragraph>The neutron.extensions.qos.QoSPluginBase class uses method proxies for methods
                    relating to QoS policy rules. Each of these such methods is generic in the sense
                    that it is intended to handle any rule type. For example, QoSPluginBase has a
                    create_policy_rule method instead of both create_policy_dscp_marking_rule and
                    create_policy_bandwidth_limit_rule methods. The logic behind the proxies allows
                    a call to a plugin’s create_policy_dscp_marking_rule to be handled by the
                    create_policy_rule method, which will receive a QosDscpMarkingRule object as an
                    argument in order to execute behavior specific to the DSCP marking rule type.
                    This approach allows new rule types to be introduced without requiring a plugin
                    to modify code as a result. As would be expected, any subclass of QoSPluginBase
                    must override the base class’s abc.abstractmethod methods, even if to raise
                    NotImplemented.</paragraph>
            </section>
            <section ids="supported-qos-rule-types" names="supported\ qos\ rule\ types">
                <title>Supported QoS rule types</title>
                <paragraph>Each QoS driver has a property called supported_rule_types, where the driver
                    exposes the rules it’s able to handle.</paragraph>
                <paragraph>For a list of all rule types, see:
                    neutron.services.qos.qos_consts.VALID_RULE_TYPES.</paragraph>
                <paragraph>The list of supported QoS rule types exposed by neutron is calculated as
                    the common subset of rules supported by all active QoS drivers.</paragraph>
                <paragraph>Note: the list of supported rule types reported by core plugin is not enforced
                    when accessing QoS rule resources. This is mostly because then we would not be
                    able to create rules while at least one of the QoS driver in gate lacks
                    support for the rules we’re trying to test.</paragraph>
            </section>
            <section ids="database-models" names="database\ models">
                <title>Database models</title>
                <paragraph>QoS design defines the following two conceptual resources to apply QoS rules
                    for a port or a network:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>QoS policy</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>QoS rule (type specific)</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Each QoS policy contains zero or more QoS rules. A policy is then applied to a
                    network or a port, making all rules of the policy applied to the corresponding
                    Neutron resource.</paragraph>
                <paragraph>When applied through a network association, policy rules could apply or not
                    to neutron internal ports (like router, dhcp, load balancer, etc..). The QosRule
                    base object provides a default should_apply_to_port method which could be
                    overridden. In the future we may want to have a flag in QoSNetworkPolicyBinding
                    or QosRule to enforce such type of application (for example when limiting all
                    the ingress of routers devices on an external network automatically).</paragraph>
                <paragraph>Each project can have at most one default QoS policy, although is not
                    mandatory. If a default QoS policy is defined, all new networks created within
                    this project will have assigned this policy, as long as no other QoS policy is
                    explicitly attached during the creation process. If the default QoS policy is
                    unset, no change to existing networks will be made.</paragraph>
                <paragraph>From database point of view, following objects are defined in schema:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>QosPolicy: directly maps to the conceptual policy resource.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>QosNetworkPolicyBinding, QosPortPolicyBinding: defines attachment between a
                            Neutron resource and a QoS policy.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>QosPolicyDefault: defines a default QoS policy per project.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>QosBandwidthLimitRule: defines the rule to limit the maximum egress
                            bandwidth.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>QosDscpMarkingRule: defines the rule that marks the Differentiated Service
                            bits for egress traffic.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>QosMinimumBandwidthRule: defines the rule that creates a minimum bandwidth
                            constraint.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>All database models are defined under:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>neutron.db.qos.models</paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="qos-versioned-objects" names="qos\ versioned\ objects">
                <title>QoS versioned objects</title>
                <paragraph>For QoS, the following neutron objects are implemented:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>QosPolicy: directly maps to the conceptual policy resource, as defined above.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>QosPolicyDefault: defines a default QoS policy per project.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>QosBandwidthLimitRule: defines the instance bandwidth limit rule type,
                            characterized by a max kbps and a max burst kbits. This rule has also a
                            direction parameter to set the traffic direction, from the instance’s point of view.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>QosDscpMarkingRule: defines the DSCP rule type, characterized by an even integer
                            between 0 and 56.  These integers are the result of the bits in the DiffServ section
                            of the IP header, and only certain configurations are valid.  As a result, the list
                            of valid DSCP rule types is: 0, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32,
                            34, 36, 38, 40, 46, 48, and 56.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>QosMinimumBandwidthRule: defines the minimum assured bandwidth rule type,
                            characterized by a min_kbps parameter. This rule has also a direction
                            parameter to set the traffic direction, from the instance point of view. The
                            only direction now implemented is egress.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Those are defined in:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>neutron.objects.qos.policy</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>neutron.objects.qos.rule</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>For QosPolicy neutron object, the following public methods were implemented:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>get_network_policy/get_port_policy: returns a policy object that is attached
                            to the corresponding Neutron resource.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>attach_network/attach_port: attach a policy to the corresponding Neutron
                            resource.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>detach_network/detach_port: detach a policy from the corresponding Neutron
                            resource.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>In addition to the fields that belong to QoS policy database object itself,
                    synthetic fields were added to the object that represent lists of rules that
                    belong to the policy. To get a list of all rules for a specific policy, a
                    consumer of the object can just access the corresponding attribute via:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>policy.rules</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Implementation is done in a way that will allow adding a new rule list field
                    with little or no modifications in the policy object itself. This is achieved
                    by smart introspection of existing available rule object definitions and
                    automatic definition of those fields on the policy class.</paragraph>
                <paragraph>Note that rules are loaded in a non lazy way, meaning they are all fetched from
                    the database on policy fetch.</paragraph>
                <paragraph>For Qos&lt;type&gt;Rule objects, an extendable approach was taken to allow easy
                    addition of objects for new rule types. To accommodate this, fields common to
                    all types are put into a base class called QosRule that is then inherited into
                    type-specific rule implementations that, ideally, only define additional fields
                    and some other minor things.</paragraph>
                <paragraph>Note that the QosRule base class is not registered with oslo.versionedobjects
                    registry, because it’s not expected that ‘generic’ rules should be
                    instantiated (and to suggest just that, the base rule class is marked as ABC).</paragraph>
                <paragraph>QoS objects rely on some primitive database API functions that are added in:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>neutron.db.api: those can be reused to fetch other models that do not have
                            corresponding versioned objects yet, if needed.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>neutron.db.qos.api: contains database functions that are specific to QoS
                            models.</paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="rpc-communication" names="rpc\ communication">
                <title>RPC communication</title>
                <paragraph>Details on RPC communication implemented in reference backend driver are
                    discussed in <reference name="a separate page" refuri="rpc_callbacks.html">a separate page</reference><target ids="a-separate-page" names="a\ separate\ page" refuri="rpc_callbacks.html"></target>.</paragraph>
                <paragraph>The flow of updates is as follows:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>if a port that is bound to the agent is attached to a QoS policy, then ML2
                            plugin detects the change by relying on ML2 QoS extension driver, and
                            notifies the agent about a port change. The agent proceeds with the
                            notification by calling to get_device_details() and getting the new port dict
                            that contains a new qos_policy_id. Each device details dict is passed into l2
                            agent extension manager that passes it down into every enabled extension,
                            including QoS. QoS extension sees that there is a new unknown QoS policy for
                            a port, so it uses ResourcesPullRpcApi to fetch the current state of the
                            policy (with all the rules included) from the server. After that, the QoS
                            extension applies the rules by calling into QoS driver that corresponds to
                            the agent.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>on existing QoS policy update (it includes any policy or its rules change),
                            server pushes the new policy object state through ResourcesPushRpcApi
                            interface. The interface fans out the serialized (dehydrated) object to any
                            agent that is listening for QoS policy updates. If an agent have seen the
                            policy before (it is attached to one of the ports it maintains), then it goes
                            with applying the updates to the port. Otherwise, the agent silently ignores
                            the update.</paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
        <section ids="agent-side-design" names="agent\ side\ design">
            <title>Agent side design</title>
            <paragraph>Reference agents implement QoS functionality using an <reference name="L2 agent extension" refuri="./l2_agent_extensions.html">L2 agent extension</reference><target ids="l2-agent-extension" names="l2\ agent\ extension" refuri="./l2_agent_extensions.html"></target>.</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>neutron.agent.l2.extensions.qos
                        defines QoS L2 agent extension. It receives handle_port and delete_port
                        events and passes them down into QoS agent backend driver (see below). The
                        file also defines the QosAgentDriver interface. Note: each backend implements
                        its own driver. The driver handles low level interaction with the underlying
                        networking technology, while the QoS extension handles operations that are
                        common to all agents.</paragraph>
                </list_item>
            </bullet_list>
            <section ids="agent-backends" names="agent\ backends">
                <title>Agent backends</title>
                <paragraph>At the moment, QoS is supported by Open vSwitch, SR-IOV and Linux bridge
                    ml2 drivers.</paragraph>
                <paragraph>Each agent backend defines a QoS driver that implements the QosAgentDriver
                    interface:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>Open vSwitch (QosOVSAgentDriver);</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>SR-IOV (QosSRIOVAgentDriver);</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Linux bridge (QosLinuxbridgeAgentDriver).</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Table of Neutron backends, supported rules and traffic direction (from the VM
                    point of view)</paragraph>
                <literal_block xml:space="preserve">+----------------------+----------------+----------------+----------------+
| Rule \ Backend       | Open vSwitch   | SR-IOV         | Linux Bridge   |
+----------------------+----------------+----------------+----------------+
| Bandwidth Limit      | Egress/Ingress | Egress (1)     | Egress/Ingress |
+----------------------+----------------+----------------+----------------+
| Minimum Bandwidth    | -              | Egress         | -              |
+----------------------+----------------+----------------+----------------+
| DSCP Marking         | Egress         | -              | Egress         |
+----------------------+----------------+----------------+----------------+

(1) Max burst parameter is skipped because it's not supported by ip tool.</literal_block>
                <section ids="open-vswitch" names="open\ vswitch">
                    <title>Open vSwitch</title>
                    <paragraph>Open vSwitch implementation relies on the new ovs_lib OVSBridge functions:</paragraph>
                    <bullet_list bullet="*">
                        <list_item>
                            <paragraph>get_egress_bw_limit_for_port</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>create_egress_bw_limit_for_port</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>delete_egress_bw_limit_for_port</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>get_ingress_bw_limit_for_port</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>update_ingress_bw_limit_for_port</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>delete_ingress_bw_limit_for_port</paragraph>
                        </list_item>
                    </bullet_list>
                    <paragraph>An egress bandwidth limit is effectively configured on the port by setting
                        the port Interface parameters ingress_policing_rate and
                        ingress_policing_burst.</paragraph>
                    <paragraph>That approach is less flexible than linux-htb, Queues and OvS QoS profiles,
                        which we may explore in the future, but which will need to be used in
                        combination with openflow rules.</paragraph>
                    <paragraph>An ingress bandwidth limit is effectively configured on the port by setting
                        Queue and OvS QoS profile with linux-htb type for port.</paragraph>
                    <paragraph>The Open vSwitch DSCP marking implementation relies on the recent addition
                        of the ovs_agent_extension_api OVSAgentExtensionAPI to request access to the
                        integration bridge functions:</paragraph>
                    <bullet_list bullet="*">
                        <list_item>
                            <paragraph>add_flow</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>mod_flow</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>delete_flows</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>dump_flows_for</paragraph>
                        </list_item>
                    </bullet_list>
                    <paragraph>The DSCP markings are in fact configured on the port by means of
                        openflow rules.</paragraph>
                </section>
                <section ids="sr-iov" names="sr-iov">
                    <title>SR-IOV</title>
                    <paragraph>SR-IOV bandwidth limit implementation relies on the new pci_lib function:</paragraph>
                    <bullet_list bullet="*">
                        <list_item>
                            <paragraph>set_vf_max_rate</paragraph>
                        </list_item>
                    </bullet_list>
                    <paragraph>As the name of the function suggests, the limit is applied on a Virtual
                        Function (VF).</paragraph>
                    <paragraph>ip link interface has the following limitation for bandwidth limit: it uses
                        Mbps as units of bandwidth measurement, not kbps, and does not support float
                        numbers. So in case the limit is set to something less than 1000 kbps, it’s set
                        to 1 Mbps only. If the limit is set to something that does not divide to 1000
                        kbps chunks, then the effective limit is rounded to the nearest integer Mbps
                        value.</paragraph>
                </section>
            </section>
            <section ids="linux-bridge" names="linux\ bridge">
                <title>Linux bridge</title>
                <paragraph>The Linux bridge implementation relies on the new tc_lib functions.</paragraph>
                <paragraph>For egress bandwidth limit rule:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>set_filters_bw_limit</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>update_filters_bw_limit</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>delete_filters_bw_limit</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>The egress bandwidth limit is configured on the tap port by setting traffic
                    policing on tc ingress queueing discipline (qdisc). Details about ingress
                    qdisc can be found on <reference name="lartc how-to" refuri="http://lartc.org/howto/lartc.adv-qdisc.ingress.html">lartc how-to</reference>.
                    The reason why ingress qdisc is used to configure egress bandwidth limit is that
                    tc is working on traffic which is visible from “inside bridge” perspective. So
                    traffic incoming to bridge via tap interface is in fact outgoing from Neutron’s
                    port.
                    This implementation is the same as what Open vSwitch is doing when
                    ingress_policing_rate and ingress_policing_burst are set for port.</paragraph>
                <paragraph>For ingress bandwidth limit rule:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>set_tbf_bw_limit</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>update_tbf_bw_limit</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>delete_tbf_bw_limit</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>The ingress bandwidth limit is configured on the tap port by setting a simple
                    <reference name="tc-tbf" refuri="http://linux.die.net/man/8/tc-tbf">tc-tbf</reference><target ids="tc-tbf" names="tc-tbf" refuri="http://linux.die.net/man/8/tc-tbf"></target> queueing discipline (qdisc) on the
                    port. It requires a value of HZ parameter configured in kernel on the host.
                    This value is necessary to calculate the minimal burst value which is set in
                    tc. Details about how it is calculated can be found in
                    <reference name="here" refuri="http://unix.stackexchange.com/a/100797">here</reference><target ids="here" names="here" refuri="http://unix.stackexchange.com/a/100797"></target>. This solution is similar to Open
                    vSwitch implementation.</paragraph>
                <paragraph>The Linux bridge DSCP marking implementation relies on the
                    linuxbridge_extension_api to request access to the IptablesManager class
                    and to manage chains in the <literal>mangle</literal> table in iptables.</paragraph>
            </section>
        </section>
        <section ids="qos-driver-design" names="qos\ driver\ design">
            <title>QoS driver design</title>
            <paragraph>QoS framework is flexible enough to support any third-party vendor. To integrate a
                third party driver (that just wants to be aware of the QoS create/update/delete API
                calls), one needs to implement ‘neutron.services.qos.drivers.base’, and register
                the driver during the core plugin or mechanism driver load, see</paragraph>
            <paragraph>neutron.services.qos.drivers.openvswitch.driver register method for an example.</paragraph>
            <note>
                <paragraph>All the functionality MUST be implemented by the vendor, neutron’s QoS framework
                    will just act as an interface to bypass the received QoS API request and help with
                    database persistence for the API operations.</paragraph>
            </note>
        </section>
        <section ids="configuration" names="configuration">
            <title>Configuration</title>
            <paragraph>To enable the service, the following steps should be followed:</paragraph>
            <paragraph>On server side:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>enable qos service in service_plugins;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>for ml2, add ‘qos’ to extension_drivers in [ml2] section.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>On agent side (OVS):</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>add ‘qos’ to extensions in [agent] section.</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="testing-strategy" names="testing\ strategy">
            <title>Testing strategy</title>
            <paragraph>All the code added or extended as part of the effort got reasonable unit test
                coverage.</paragraph>
            <section ids="neutron-objects" names="neutron\ objects">
                <title>Neutron objects</title>
                <paragraph>Base unit test classes to validate neutron objects were implemented in a way
                    that allows code reuse when introducing a new object type.</paragraph>
                <paragraph>There are two test classes that are utilized for that:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>BaseObjectIfaceTestCase: class to validate basic object operations (mostly
                            CRUD) with database layer isolated.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>BaseDbObjectTestCase: class to validate the same operations with models in
                            place and database layer unmocked.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Every new object implemented on top of one of those classes is expected to
                    either inherit existing test cases as is, or reimplement it, if it makes sense
                    in terms of how those objects are implemented. Specific test classes can
                    obviously extend the set of test cases as they see needed (f.e. you need to
                    define new test cases for those additional methods that you may add to your
                    object implementations on top of base semantics common to all neutron objects).</paragraph>
            </section>
            <section ids="functional-tests" names="functional\ tests">
                <title>Functional tests</title>
                <paragraph>Additions to ovs_lib to set bandwidth limits on ports are covered in:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>neutron.tests.functional.agent.test_ovs_lib</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>New functional tests for tc_lib to set bandwidth limits on ports are in:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>neutron.tests.functional.agent.linux.test_tc_lib</paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="api-tests" names="api\ tests">
                <title>API tests</title>
                <paragraph>API tests for basic CRUD operations for ports, networks, policies, and rules were added in:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>neutron.tests.tempest.api.test_qos</paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
    </section>
</document>
