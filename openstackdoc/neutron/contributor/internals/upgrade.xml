<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document source="/home/fbaumanis/openstack/soc8_test/openstack_repo/neutron/doc/source/contributor/internals/upgrade.rst">
    <comment xml:space="preserve">Licensed under the Apache License, Version 2.0 (the "License"); you may
not use this file except in compliance with the License. You may obtain
a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations
under the License.


Convention for heading levels in Neutron devref:
=======  Heading 0 (reserved for the title in a document)
-------  Heading 1
~~~~~~~  Heading 2
+++++++  Heading 3
'''''''  Heading 4
(Avoid deeper levels because they do not render well.)</comment>
    <note>
        <paragraph>Much of this document discusses upgrade considerations for the Neutron
            reference implementation using Neutron’s agents. It’s expected that each
            Neutron plugin provides its own documentation that discusses upgrade
            considerations specific to that choice of backend. For example, OVN does
            not use Neutron agents, but does have a local controller that runs on each
            compute node. OVN supports rolling upgrades, but information about how that
            works should be covered in the documentation for networking-ovn, the OVN
            Neutron plugin.</paragraph>
    </note>
    <section ids="upgrade-strategy" names="upgrade\ strategy">
        <title>Upgrade strategy</title>
        <paragraph>There are two general upgrade scenarios supported by Neutron:</paragraph>
        <enumerated_list enumtype="arabic" prefix="" suffix=".">
            <list_item>
                <paragraph>All services are shut down, code upgraded, then all services are started again.</paragraph>
            </list_item>
            <list_item>
                <paragraph>Services are upgraded gradually, based on operator service windows.</paragraph>
            </list_item>
        </enumerated_list>
        <paragraph>The latter is the preferred way to upgrade an OpenStack cloud, since it allows
            for more granularity and less service downtime. This scenario is usually called
            ‘rolling upgrade’.</paragraph>
        <section ids="rolling-upgrade" names="rolling\ upgrade">
            <title>Rolling upgrade</title>
            <paragraph>Rolling upgrades imply that during some interval of time there will be services
                of different code versions running and interacting in the same cloud. It puts
                multiple constraints onto the software.</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>older services should be able to talk with newer services.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>older services should not require the database to have older schema
                        (otherwise newer services that require the newer schema would not work).</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph><reference name="More info on rolling upgrades in OpenStack" refuri="http://governance.openstack.org/reference/tags/assert_supports-rolling-upgrade.html">More info on rolling upgrades in OpenStack</reference><target ids="more-info-on-rolling-upgrades-in-openstack" names="more\ info\ on\ rolling\ upgrades\ in\ openstack" refuri="http://governance.openstack.org/reference/tags/assert_supports-rolling-upgrade.html"></target>.</paragraph>
            <paragraph>Those requirements are achieved in Neutron by:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>If the Neutron backend makes use of Neutron agents, the Neutron server have
                        backwards compatibility code to deal with older messaging payloads.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>isolating a single service that accesses database (neutron-server).</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>To simplify the matter, it’s always assumed that the order of service upgrades
                is as following:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>first, all neutron-servers are upgraded.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>then, if applicable, neutron agents are upgraded.</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>This approach allows us to avoid backwards compatibility code on agent side and
                is in line with other OpenStack projects that support rolling upgrades
                (specifically, nova).</paragraph>
            <section ids="server-upgrade" names="server\ upgrade">
                <title>Server upgrade</title>
                <paragraph>Neutron-server is the very first component that should be upgraded to the new
                    code. It’s also the only component that relies on new database schema to be
                    present, other components communicate with the cloud through AMQP and hence do
                    not depend on particular database state.</paragraph>
                <paragraph>Database upgrades are implemented with alembic migration chains.</paragraph>
                <paragraph>Database upgrade is split into two parts:</paragraph>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph><literal>neutron-db-manage upgrade --expand</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>neutron-db-manage upgrade --contract</literal></paragraph>
                    </list_item>
                </enumerated_list>
                <paragraph>Each part represents a separate alembic branch.</paragraph>
                <paragraph>The former step can be executed while old neutron-server code is running. The
                    latter step requires <emphasis>all</emphasis> neutron-server instances to be shut down. Once it’s
                    complete, neutron-servers can be started again.</paragraph>
                <note>
                    <paragraph>Full shutdown of neutron-server instances can be skipped depending on
                        whether there are pending contract scripts not applied to the database:</paragraph>
                    <literal_block xml:space="preserve">$ neutron-db-manage has_offline_migrations
Command will return a message if there are pending contract scripts.</literal_block>
                </note>
                <paragraph><reference internal="True" refuri="../alembic_migrations#alembic-migrations"><inline classes="std std-ref">More info on alembic scripts</inline></reference>.</paragraph>
            </section>
            <section ids="agents-upgrade" names="agents\ upgrade">
                <title>Agents upgrade</title>
                <note>
                    <paragraph>This section does not apply when the cloud does not use AMQP agents to
                        provide networking services to instances. In that case, other backend
                        specific upgrade instructions may also apply.</paragraph>
                </note>
                <paragraph>Once neutron-server services are restarted with the new database schema and the
                    new code, it’s time to upgrade Neutron agents.</paragraph>
                <paragraph>Note that in the meantime, neutron-server should be able to serve AMQP messages
                    sent by older versions of agents which are part of the cloud.</paragraph>
                <paragraph>The recommended order of agent upgrade (per node) is:</paragraph>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>first, L2 agents (openvswitch, linuxbridge, sr-iov).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>then, all other agents (L3, DHCP, Metadata, …).</paragraph>
                    </list_item>
                </enumerated_list>
                <paragraph>The rationale of the agent upgrade order is that L2 agent is usually
                    responsible for wiring ports for other agents to use, so it’s better to allow
                    it to do its job first and then proceed with other agents that will use the
                    already configured ports for their needs.</paragraph>
                <paragraph>Each network/compute node can have its own upgrade schedule that is independent
                    of other nodes.</paragraph>
                <section ids="amqp-considerations" names="amqp\ considerations">
                    <title>AMQP considerations</title>
                    <paragraph>Since it’s always assumed that neutron-server component is upgraded before
                        agents, only the former should handle both old and new RPC versions.</paragraph>
                    <paragraph>The implication of that is that no code that handles UnsupportedVersion
                        oslo.messaging exceptions belongs to agent code.</paragraph>
                    <section ids="notifications" names="notifications">
                        <title>Notifications</title>
                        <paragraph>For notifications that are issued by neutron-server to listening agents,
                            special consideration is needed to support rolling upgrades. In this case, a
                            newer controller sends newer payload to older agents.</paragraph>
                        <paragraph>Until we have proper RPC version pinning feature to enforce older payload
                            format during upgrade (as it’s implemented in other projects like nova), we
                            leave our agents resistant against unknown arguments sent as part of server
                            notifications. This is achieved by consistently capturing those unknown
                            arguments with keyword arguments and ignoring them on agent side; and by not
                            enforcing newer RPC entry point versions on server side.</paragraph>
                        <paragraph>This approach is not ideal, because it makes RPC API less strict. That’s why
                            other approaches should be considered for notifications in the future.</paragraph>
                        <paragraph><reference internal="True" refuri="rpc_api#rpc-versioning"><inline classes="std std-ref">More information about RPC versioning</inline></reference>.</paragraph>
                    </section>
                    <section ids="interface-signature" names="interface\ signature">
                        <title>Interface signature</title>
                        <paragraph>An RPC interface is defined by its name, version, and (named) arguments that
                            it accepts. There are no strict guarantees that arguments will have expected
                            types or meaning, as long as they are serializable.</paragraph>
                    </section>
                    <section ids="message-content-versioning" names="message\ content\ versioning">
                        <title>Message content versioning</title>
                        <paragraph>To provide better compatibility guarantees for rolling upgrades, RPC interfaces
                            could also define specific format for arguments they accept. In OpenStack
                            world, it’s usually implemented using oslo.versionedobjects library, and
                            relying on the library to define serialized form for arguments that are passed
                            through AMQP wire.</paragraph>
                        <paragraph>Note that Neutron has <emphasis>not</emphasis> adopted oslo.versionedobjects library for its RPC
                            interfaces yet (except for QoS feature).</paragraph>
                        <paragraph><reference internal="True" refuri="rpc_callbacks#rpc-callbacks"><inline classes="std std-ref">More information about RPC callbacks used for QoS</inline></reference>.</paragraph>
                    </section>
                </section>
            </section>
            <section ids="networking-backends" names="networking\ backends">
                <title>Networking backends</title>
                <paragraph>Backend software upgrade should not result in any data plane disruptions.
                    Meaning, e.g. Open vSwitch L2 agent should not reset flows or rewire ports;
                    Neutron L3 agent should not delete namespaces left by older version of the
                    agent; Neutron DHCP agent should not require immediate DHCP lease renewal; etc.</paragraph>
                <paragraph>The same considerations apply to setups that do not rely on agents. Meaning,
                    f.e. OpenDaylight or OVN controller should not break data plane connectivity
                    during its upgrade process.</paragraph>
            </section>
        </section>
        <section ids="upgrade-testing" names="upgrade\ testing">
            <title>Upgrade testing</title>
            <paragraph><reference name="Grenade" refuri="https://github.com/openstack-dev/grenade">Grenade</reference><target ids="grenade" names="grenade" refuri="https://github.com/openstack-dev/grenade"></target> is the OpenStack project
                that is designed to validate upgrade scenarios.</paragraph>
            <paragraph>Currently, only offline (non-rolling) upgrade scenario is validated in Neutron
                gate. The upgrade scenario follows the following steps:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>the ‘old’ cloud is set up using latest stable release code</paragraph>
                </list_item>
                <list_item>
                    <paragraph>all services are stopped</paragraph>
                </list_item>
                <list_item>
                    <paragraph>code is updated to the patch under review</paragraph>
                </list_item>
                <list_item>
                    <paragraph>new database migration scripts are applied, if needed</paragraph>
                </list_item>
                <list_item>
                    <paragraph>all services are started</paragraph>
                </list_item>
                <list_item>
                    <paragraph>the ‘new’ cloud is validated with a subset of tempest tests</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>The scenario validates that no configuration option names are changed in one
                cycle. More generally, it validates that the ‘new’ cloud is capable of running
                using the ‘old’ configuration files. It also validates that database migration
                scripts can be executed.</paragraph>
            <paragraph>The scenario does <emphasis>not</emphasis> validate AMQP versioning compatibility.</paragraph>
            <paragraph>Other projects (for example Nova) have so called ‘partial’ grenade jobs where
                some services are left running using the old version of code. Such a job would
                be needed in Neutron gate to validate rolling upgrades for the project. Till
                that time, it’s all up to reviewers to catch compatibility issues in patches on
                review.</paragraph>
            <paragraph>Another hole in testing belongs to split migration script branches. It’s
                assumed that an ‘old’ cloud can successfully run after ‘expand’ migration
                scripts from the ‘new’ cloud are applied to its database; but it’s not
                validated in gate.</paragraph>
            <target refid="upgrade-review-guidelines"></target>
        </section>
        <section ids="review-guidelines upgrade-review-guidelines" names="review\ guidelines upgrade_review_guidelines">
            <title>Review guidelines</title>
            <paragraph>There are several upgrade related gotchas that should be tracked by reviewers.</paragraph>
            <paragraph>First things first, a general advice to reviewers: make sure new code does not
                violate requirements set by <reference name="global OpenStack deprecation policy" refuri="http://governance.openstack.org/reference/tags/assert_follows-standard-deprecation.html">global OpenStack deprecation policy</reference><target ids="global-openstack-deprecation-policy" names="global\ openstack\ deprecation\ policy" refuri="http://governance.openstack.org/reference/tags/assert_follows-standard-deprecation.html"></target>.</paragraph>
            <paragraph>Now to specifics:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Configuration options:</paragraph>
                    <bullet_list bullet="*">
                        <list_item>
                            <paragraph>options should not be dropped from the tree without waiting for
                                deprecation period (currently it’s one development cycle long) and a
                                deprecation message issued if the deprecated option is used.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>option values should not change their meaning between releases.</paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
                <list_item>
                    <paragraph>Data plane:</paragraph>
                    <bullet_list bullet="*">
                        <list_item>
                            <paragraph>agent restart should not result in data plane disruption (no Open vSwitch
                                ports reset; no network namespaces deleted; no device names changed).</paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
                <list_item>
                    <paragraph>RPC versioning:</paragraph>
                    <bullet_list bullet="*">
                        <list_item>
                            <paragraph>no RPC version major number should be bumped before all agents had a
                                chance to upgrade (meaning, at least one release cycle is needed before
                                compatibility code to handle old clients is stripped from the tree).</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>no compatibility code should be added to agent side of AMQP interfaces.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>server code should be able to handle all previous versions of agents,
                                unless the major version of an interface is bumped.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>no RPC interface arguments should change their meaning, or names.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>new arguments added to RPC interfaces should not be mandatory. It means
                                that server should be able to handle old requests, without the new
                                argument specified. Also, if the argument is not passed, the old behaviour
                                before the addition of the argument should be retained.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>minimal client version must not be bumped for server initiated
                                notification changes for at least one cycle.</paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
                <list_item>
                    <paragraph>Database migrations:</paragraph>
                    <bullet_list bullet="*">
                        <list_item>
                            <paragraph>migration code should be split into two branches (contract, expand) as
                                needed. No code that is unsafe to execute while neutron-server is running
                                should be added to expand branch.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>if possible, contract migrations should be minimized or avoided to reduce
                                the time when API endpoints must be down during database upgrade.</paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
            </enumerated_list>
        </section>
    </section>
</document>
