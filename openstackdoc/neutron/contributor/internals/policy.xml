<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document source="/home/fbaumanis/openstack/soc8_test/openstack_repo/neutron/doc/source/contributor/internals/policy.rst">
    <comment xml:space="preserve">Licensed under the Apache License, Version 2.0 (the "License"); you may
not use this file except in compliance with the License. You may obtain
a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations
under the License.


Convention for heading levels in Neutron devref:
=======  Heading 0 (reserved for the title in a document)
-------  Heading 1
~~~~~~~  Heading 2
+++++++  Heading 3
'''''''  Heading 4
(Avoid deeper levels because they do not render well.)</comment>
    <section ids="authorization-policy-enforcement" names="authorization\ policy\ enforcement">
        <title>Authorization Policy Enforcement</title>
        <paragraph>As most OpenStack projects, Neutron leverages oslo_policy <footnote_reference auto="1" ids="id1" refid="id7">1</footnote_reference>. However, since
            Neutron loves to be special and complicate every developer’s life, it also
            “augments” oslo_policy capabilities by:</paragraph>
        <block_quote>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>A wrapper module with its own API: neutron.policy;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The ability of adding fine-grained checks on attributes for resources in
                        request bodies;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The ability of using the policy engine to filter out attributes in responses;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Adding some custom rule checks beyond those defined in oslo_policy;</paragraph>
                </list_item>
            </bullet_list>
        </block_quote>
        <paragraph>This document discusses Neutron-specific aspects of policy enforcement, and in
            particular how the enforcement logic is wired into API processing.
            For any other information please refer to the developer documentation for
            oslo_policy <footnote_reference auto="1" ids="id2" refid="id8">2</footnote_reference>.</paragraph>
        <section ids="authorization-workflow" names="authorization\ workflow">
            <title>Authorization workflow</title>
            <paragraph>The Neutron API controllers perform policy checks in two phases during the
                processing of an API request:</paragraph>
            <block_quote>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>Request authorization, immediately before dispatching the request to the
                            plugin layer for <literal>POST</literal>, <literal>PUT</literal>, and <literal>DELETE</literal>, and immediately after
                            returning from the plugin layer for <literal>GET</literal> requests;</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Response filtering, when building the response to be returned to the API
                            consumer.</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
            <section ids="request-authorization" names="request\ authorization">
                <title>Request authorization</title>
                <paragraph>The aim of this step is to authorize processing for a request or reject it
                    with an error status code.
                    This step uses the <literal>neutron.policy.enforce</literal> routine. This routine raises
                    <literal>oslo_policy.PolicyNotAuthorized</literal> when policy enforcement fails. The Neutron
                    REST API controllers catch this exception and return:</paragraph>
                <block_quote>
                    <bullet_list bullet="*">
                        <list_item>
                            <paragraph>A 403 response code on a <literal>POST</literal> request or an <literal>PUT</literal> request for an
                                object owned by the project submitting the request;</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>A 403 response for failures while authorizing API actions such as
                                <literal>add_router_interface</literal>;</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>A 404 response for <literal>DELETE</literal>, <literal>GET</literal> and all other <literal>PUT</literal> requests.</paragraph>
                        </list_item>
                    </bullet_list>
                </block_quote>
                <paragraph>For <literal>DELETE</literal> operations the resource must first be fetched. This is done
                    invoking the same <literal>_item</literal> <footnote_reference auto="1" ids="id3" refid="id9">3</footnote_reference> method used for processing <literal>GET</literal> requests.
                    This is also true for <literal>PUT</literal> operations, since the Neutron API implements
                    <literal>PATCH</literal> semantics for <literal>PUTs</literal>.
                    The criteria to evaluate are built in the <literal>_build_match_rule</literal> <footnote_reference auto="1" ids="id4" refid="id10">4</footnote_reference> routine.
                    This routine takes in input the following parameters:</paragraph>
                <block_quote>
                    <bullet_list bullet="*">
                        <list_item>
                            <paragraph>The action to be performed, in the <literal>&lt;operation&gt;_&lt;resource&gt;</literal> form,
                                <literal>e.g.: create_network</literal></paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>The data to use for performing checks. For <literal>POST</literal> operations this could
                                be a partial specification of the object, whereas it is always a full
                                specification for <literal>GET</literal>, <literal>PUT</literal>, and <literal>DELETE</literal> requests, as resource
                                data are retrieved before dispatching the call to the plugin layer.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>The collection name for the resource specified in the previous parameter;
                                for instance, for a network it would be the “networks”.</paragraph>
                        </list_item>
                    </bullet_list>
                </block_quote>
                <paragraph>The <literal>_build_match_rule</literal> routine returns a <literal>oslo_policy.RuleCheck</literal> instance
                    built in the following way:</paragraph>
                <block_quote>
                    <bullet_list bullet="*">
                        <list_item>
                            <paragraph>Always add a check for the action being performed. This will match
                                a policy like create_network in <literal>policy.json</literal>;</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Return for <literal>GET</literal> operations; more detailed checks will be performed anyway
                                when building the response;</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>For each attribute which has been explicitly specified in the request
                                create a rule matching policy names in the form
                                <literal>&lt;operation&gt;_&lt;resource&gt;:&lt;attribute&gt;</literal> rule, and link it with the
                                previous rule with an ‘And’ relationship (using <literal>oslo_policy.AndCheck</literal>);
                                this step will be performed only if the enforce_policy flag is set to
                                True in the resource attribute descriptor (usually found in a data
                                structure called <literal>RESOURCE_ATTRIBUTE_MAP</literal>);</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>If the attribute is a composite one then further rules will be created;
                                These will match policy names in the form <literal>&lt;operation&gt;_&lt;resource&gt;:
&lt;attribute&gt;:&lt;sub_attribute&gt;</literal>. An ‘And’ relationship will be used in this
                                case too.</paragraph>
                        </list_item>
                    </bullet_list>
                </block_quote>
                <paragraph>As all the rules to verify are linked by ‘And’ relationships, all the policy
                    checks should succeed in order for a request to be authorized. Rule
                    verification is performed by <literal>oslo_policy</literal> with no “customization” from the
                    Neutron side.</paragraph>
            </section>
            <section ids="response-filtering" names="response\ filtering">
                <title>Response Filtering</title>
                <paragraph>Some Neutron extensions, like the provider networks one, add some attribute
                    to resources which are however not meant to be consumed by all clients. This
                    might be because these attributes contain implementation details, or are
                    meant only to be used when exchanging information between services, such
                    as Nova and Neutron;</paragraph>
                <paragraph>For this reason the policy engine is invoked again when building API
                    responses. This is achieved by the <literal>_exclude_attributes_by_policy</literal> <footnote_reference auto="1" ids="id5" refid="id11">5</footnote_reference>
                    method in <literal>neutron.api.v2.base.Controller</literal>;</paragraph>
                <paragraph>This method, for each attribute in the response returned by the plugin layer,
                    first checks if the <literal>is_visible</literal> flag is True. In that case it proceeds to
                    checking policies for the attribute; if the policy check fails the attribute
                    is added to a list of attributes that should be removed from the response
                    before returning it to the API client.</paragraph>
            </section>
        </section>
        <section ids="the-neutron-policy-api" names="the\ neutron.policy\ api">
            <title>The neutron.policy API</title>
            <paragraph>The <literal>neutron.policy</literal> module exposes a simple API whose main goal if to allow the
                REST API controllers to implement the authorization workflow discussed in this
                document. It is a bad practice to call the policy engine from within the plugin
                layer, as this would make request authorization dependent on configured
                plugins, and therefore make API behaviour dependent on the plugin itself, which
                defies Neutron tenet of being backend agnostic.</paragraph>
            <paragraph>The neutron.policy API exposes the following routines:</paragraph>
            <block_quote>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph><literal>init</literal>
                            Initializes the policy engine loading rules from the json policy (files).
                            This method can safely be called several times.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>reset</literal>
                            Clears all the rules currently configured in the policy engine. It is
                            called in unit tests and at the end of the initialization of core API
                            router <footnote_reference auto="1" ids="id6" refid="id12">6</footnote_reference> in order to ensure rules are loaded after all the extensions
                            are loaded.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>refresh</literal>
                            Combines init and reset. Called when a SIGHUP signal is sent to an API
                            worker.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>set_rules</literal>
                            Explicitly set policy engine’s rules. Used only in unit tests.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>check</literal>
                            Perform a check using the policy engine. Builds match rules as described
                            in this document, and then evaluates the resulting rule using oslo_policy’s
                            policy engine. Returns True if the checks succeeds, false otherwise.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>enforce</literal>
                            Operates like the check routine but raises if the check in oslo_policy
                            fails.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>check_is_admin</literal>
                            Enforce the predefined context_is_admin rule; used to determine the is_admin
                            property for a neutron context.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>check_is_advsvc</literal>
                            Enforce the predefined context_is_advsvc rule; used to determine the
                            is_advsvc property for a neutron context.</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
        </section>
        <section ids="neutron-specific-policy-rules" names="neutron\ specific\ policy\ rules">
            <title>Neutron specific policy rules</title>
            <paragraph>Neutron provides two additional policy rule classes in order to support the
                “augmented” authorization capabilities it provides. They both extend
                <literal>oslo_policy.RuleCheck</literal> and are registered using the
                <literal>oslo_policy.register</literal> decorator.</paragraph>
            <section ids="ownercheck-extended-checks-for-resource-ownership" names="ownercheck:\ extended\ checks\ for\ resource\ ownership">
                <title>OwnerCheck: Extended Checks for Resource Ownership</title>
                <paragraph>This class is registered for rules matching the <literal>tenant_id</literal> keyword and
                    overrides the generic check performed by oslo_policy in this case.
                    It uses for those cases where neutron needs to check whether the project
                    submitting a request for a new resource owns the parent resource of the one
                    being created. Current usages of <literal>OwnerCheck</literal> include, for instance,
                    creating and updating a subnet.</paragraph>
                <paragraph>The check, performed in the <literal>__call__</literal> method, works as follows:</paragraph>
                <block_quote>
                    <bullet_list bullet="*">
                        <list_item>
                            <paragraph>verify if the target field is already in the target data. If yes, then
                                simply verify whether the value for the target field in target data
                                is equal to value for the same field in credentials, just like
                                <literal>oslo_policy.GeneriCheck</literal> would do. This is also the most frequent case
                                as the target field is usually <literal>tenant_id</literal>;</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>if the previous check failed, extract a parent resource type and a
                                parent field name from the target field. For instance
                                <literal>networks:tenant_id</literal> identifies the <literal>tenant_id</literal> attribute of the
                                <literal>network</literal> resource;</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>if no parent resource or target field could be identified raise a
                                <literal>PolicyCheckError</literal> exception;</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Retrieve a ‘parent foreign key’ from the <literal>RESOURCE_FOREIGN_KEYS</literal> data
                                structure in <literal>neutron.api.v2.attributes</literal>. This foreign key is simply the
                                attribute acting as a primary key in the parent resource. A
                                <literal>PolicyCheckError</literal> exception will be raised if such ‘parent foreign key’
                                cannot be retrieved;</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Using the core plugin, retrieve an instance of the resource having
                                ‘parent foreign key’ as an identifier;</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Finally, verify whether the target field in this resource matches the
                                one in the initial request data. For instance, for a port create request,
                                verify whether the <literal>tenant_id</literal> of the port data structure matches the
                                <literal>tenant_id</literal> of the network where this port is being created.</paragraph>
                        </list_item>
                    </bullet_list>
                </block_quote>
            </section>
            <section ids="fieldcheck-verify-resource-attributes" names="fieldcheck:\ verify\ resource\ attributes">
                <title>FieldCheck: Verify Resource Attributes</title>
                <paragraph>This class is registered with the policy engine for rules matching the ‘field’
                    keyword, and provides a way to perform fine grained checks on resource
                    attributes. For instance, using this class of rules it is possible to specify
                    a rule for granting every project read access to shared resources.</paragraph>
                <paragraph>In policy.json, a FieldCheck rules is specified in the following way:</paragraph>
                <literal_block xml:space="preserve">&gt; field: &lt;resource&gt;:&lt;field&gt;=&lt;value&gt;</literal_block>
                <paragraph>This will result in the initialization of a FieldCheck that will check for
                    <literal>&lt;field&gt;</literal> in the target resource data, and return <literal>True</literal> if it is equal
                    to <literal>&lt;value&gt;</literal> or return <literal>False</literal> is the <literal>&lt;field&gt;</literal> either is not equal to
                    <literal>&lt;value&gt;</literal> or does not exist at all.</paragraph>
            </section>
        </section>
        <section ids="guidance-for-api-developers" names="guidance\ for\ api\ developers">
            <title>Guidance for API developers</title>
            <paragraph>When developing REST APIs for Neutron it is important to be aware of how the
                policy engine will authorize these requests. This is true both for APIs
                served by Neutron “core” and for the APIs served by the various Neutron
                “stadium” services.</paragraph>
            <block_quote>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>If an attribute of a resource might be subject to authorization checks
                            then the <literal>enforce_policy</literal> attribute should be set to <literal>True</literal>. While
                            setting this flag to <literal>True</literal> for each attribute is a viable strategy,
                            it is worth noting that this will require a call to the policy engine
                            for each attribute, thus consistently increasing the time required to
                            complete policy checks for a resource. This could result in a scalability
                            issue, especially in the case of list operations retrieving a large
                            number of resources;</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Some resource attributes, even if not directly used in policy checks
                            might still be required by the policy engine. This is for instance the
                            case of the <literal>tenant_id</literal> attribute. For these attributes the
                            <literal>required_by_policy</literal> attribute should always set to <literal>True</literal>. This will
                            ensure that the attribute is included in the resource data sent to the
                            policy engine for evaluation;</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>The <literal>tenant_id</literal> attribute is a fundamental one in Neutron API request
                            authorization. The default policy, <literal>admin_or_owner</literal>, uses it to validate
                            if a project owns the resource it is trying to operate on. To this aim,
                            if a resource without a tenant_id is created, it is important to ensure
                            that ad-hoc authZ policies are specified for this resource.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>There is still only one check which is hardcoded in Neutron’s API layer:
                            the check to verify that a project owns the network on which it is creating
                            a port. This check is hardcoded and is always executed when creating a
                            port, unless the network is shared. Unfortunately a solution for performing
                            this check in an efficient way through the policy engine has not yet been
                            found. Due to its nature, there is no way to override this check using the
                            policy engine.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>It is strongly advised to not perform policy checks in the plugin or in
                            the database management classes. This might lead to divergent API
                            behaviours across plugins. Also, it might leave the Neutron DB in an
                            inconsistent state if a request is not authorized after it has already
                            been dispatched to the backend.</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
        </section>
        <section ids="notes" names="notes">
            <title>Notes</title>
            <block_quote>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>No authorization checks are performed for requests coming from the RPC over
                            AMQP channel. For all these requests a neutron admin context is built, and
                            the plugins will process them as such.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>For <literal>PUT</literal> and <literal>DELETE</literal> requests a 404 error is returned on request
                            authorization failures rather than a 403, unless the project submitting the
                            request own the resource to update or delete. This is to avoid conditions
                            in which an API client might try and find out other projects’ resource
                            identifiers by sending out <literal>PUT</literal> and <literal>DELETE</literal> requests for random
                            resource identifiers.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>There is no way at the moment to specify an <literal>OR</literal> relationship between two
                            attributes of a given resource (eg.: <literal>port.name == 'meh' or
port.status == 'DOWN'</literal>), unless the rule with the or condition is explicitly
                            added to the policy.json file.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>OwnerCheck</literal> performs a plugin access; this will likely require a database
                            access, but since the behaviour is implementation specific it might also
                            imply a round-trip to the backend. This class of checks, when involving
                            retrieving attributes for ‘parent’ resources should be used very sparingly.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>In order for <literal>OwnerCheck</literal> rules to work, parent resources should have an
                            entry in <literal>neutron.api.v2.attributes.RESOURCE_FOREIGN_KEYS</literal>; moreover the
                            resource must be managed by the ‘core’ plugin (ie: the one defined in the
                            core_plugin configuration variable)</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
        </section>
        <section ids="references" names="references">
            <title>References</title>
            <footnote auto="1" backrefs="id1" ids="id7" names="1">
                <label>1</label>
                <paragraph><reference name="Oslo policy module" refuri="http://git.openstack.org/cgit/openstack/oslo.policy/">Oslo policy module</reference><target ids="oslo-policy-module" names="oslo\ policy\ module" refuri="http://git.openstack.org/cgit/openstack/oslo.policy/"></target></paragraph>
            </footnote>
            <footnote auto="1" backrefs="id2" ids="id8" names="2">
                <label>2</label>
                <paragraph><reference name="Oslo policy developer" refuri="https://docs.openstack.org/oslo.policy/latest/">Oslo policy developer</reference><target ids="oslo-policy-developer" names="oslo\ policy\ developer" refuri="https://docs.openstack.org/oslo.policy/latest/"></target></paragraph>
            </footnote>
            <footnote auto="1" backrefs="id3" ids="id9" names="3">
                <label>3</label>
                <paragraph>API controller <reference name="item" refuri="http://git.openstack.org/cgit/openstack/neutron/tree/neutron/api/v2/base.py?id=2015.1.1#n282">item</reference> method</paragraph>
            </footnote>
            <target ids="item" names="item" refuri="http://git.openstack.org/cgit/openstack/neutron/tree/neutron/api/v2/base.py?id=2015.1.1#n282"></target>
            <footnote auto="1" backrefs="id4" ids="id10" names="4">
                <label>4</label>
                <paragraph>Policy engine’s <reference name="build_match_rule" refuri="http://git.openstack.org/cgit/openstack/neutron/tree/neutron/policy.py?id=2015.1.1#n187">build_match_rule</reference> method</paragraph>
            </footnote>
            <target ids="build-match-rule" names="build_match_rule" refuri="http://git.openstack.org/cgit/openstack/neutron/tree/neutron/policy.py?id=2015.1.1#n187"></target>
            <footnote auto="1" backrefs="id5" ids="id11" names="5">
                <label>5</label>
                <paragraph><reference name="exclude_attributes_by_policy" refuri="http://git.openstack.org/cgit/openstack/neutron/tree/neutron/api/v2/base.py?id=2015.1.1#n132">exclude_attributes_by_policy</reference> method</paragraph>
            </footnote>
            <target ids="exclude-attributes-by-policy" names="exclude_attributes_by_policy" refuri="http://git.openstack.org/cgit/openstack/neutron/tree/neutron/api/v2/base.py?id=2015.1.1#n132"></target>
            <footnote auto="1" backrefs="id6" ids="id12" names="6">
                <label>6</label>
                <paragraph>Policy <reference name="reset" refuri="http://git.openstack.org/cgit/openstack/neutron/tree/neutron/api/v2/router.py?id=2015.1.1#n122">reset</reference> in neutron.api.v2.router</paragraph>
            </footnote>
            <target ids="reset" names="reset" refuri="http://git.openstack.org/cgit/openstack/neutron/tree/neutron/api/v2/router.py?id=2015.1.1#n122"></target>
        </section>
    </section>
</document>
