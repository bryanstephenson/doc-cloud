<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.13.1 -->
<document source="/home/fbaumanis/openstack/soc8_test/openstack_repo/neutron/doc/source/contributor/contribute.rst">
    <comment xml:space="preserve">Licensed under the Apache License, Version 2.0 (the "License"); you may
not use this file except in compliance with the License. You may obtain
a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations
under the License.


Convention for heading levels in Neutron devref:
=======  Heading 0 (reserved for the title in a document)
-------  Heading 1
~~~~~~~  Heading 2
+++++++  Heading 3
'''''''  Heading 4
(Avoid deeper levels because they do not render well.)</comment>
    <section ids="contributing-new-extensions-to-neutron" names="contributing\ new\ extensions\ to\ neutron">
        <title>Contributing new extensions to Neutron</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>Neutron has a pluggable architecture, with a number of extension points.
                This documentation covers aspects relevant to contributing new Neutron
                v2 core (aka monolithic) plugins, ML2 mechanism drivers, and L3 service
                plugins. This document will initially cover a number of process-oriented
                aspects of the contribution process, and proceed to provide a how-to guide
                that shows how to go from 0 LOC’s to successfully contributing new
                extensions to Neutron. In the remainder of this guide, we will try to
                use practical examples as much as we can so that people have working
                solutions they can start from.</paragraph>
            <paragraph>This guide is for a developer who wants to have a degree of visibility
                within the OpenStack Networking project. If you are a developer who
                wants to provide a Neutron-based solution without interacting with the
                Neutron community, you are free to do so, but you can stop reading now,
                as this guide is not for you.</paragraph>
            <paragraph>Plugins and drivers for non-reference implementations are known as
                “third-party” code. This includes code for supporting vendor products, as well
                as code for supporting open-source networking implementations.</paragraph>
            <paragraph>Before the Kilo release these plugins and drivers were included in the Neutron
                tree. During the Kilo cycle the third-party plugins and drivers underwent the
                first phase of a process called decomposition. During this phase, each plugin
                and driver moved the bulk of its logic to a separate git repository, while
                leaving a thin “shim” in the neutron tree together with the DB models and
                migrations (and perhaps some config examples).</paragraph>
            <paragraph>During the Liberty cycle the decomposition concept was taken to its conclusion
                by allowing third-party code to exist entirely out of tree. Further extension
                mechanisms have been provided to better support external plugins and drivers
                that alter the API and/or the data model.</paragraph>
            <paragraph>In the Mitaka cycle we will <strong>require</strong> all third-party code to be moved out of
                the neutron tree completely.</paragraph>
            <paragraph>‘Outside the tree’ can be anything that is publicly available: it may be a repo
                on git.openstack.org for instance, a tarball, a pypi package, etc. A
                plugin/drivers maintainer team self-governs in order to promote sharing, reuse,
                innovation, and release of the ‘out-of-tree’ deliverable. It should not be
                required for any member of the core team to be involved with this process,
                although core members of the Neutron team can participate in whichever capacity
                is deemed necessary to facilitate out-of-tree development.</paragraph>
            <paragraph>This guide is aimed at you as the maintainer of code that integrates with
                Neutron but resides in a separate repository.</paragraph>
        </section>
        <section ids="contribution-process" names="contribution\ process">
            <title>Contribution Process</title>
            <paragraph>If you want to extend OpenStack Networking with your technology, and you want
                to do it within the visibility of the OpenStack project, follow the guidelines
                and examples below. We’ll describe best practices for:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>Design and Development;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Testing and Continuous Integration;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Defect Management;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Backport Management for plugin specific code;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>DevStack Integration;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Documentation;</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Once you have everything in place you may want to add your project to the list
                of Neutron sub-projects. See <reference internal="True" refuri="stadium/governance#add-remove-projects-to-stadium"><inline classes="std std-ref">Adding or removing projects to the Stadium</inline></reference>
                for details.</paragraph>
        </section>
        <section ids="design-and-development" names="design\ and\ development">
            <title>Design and Development</title>
            <paragraph>Assuming you have a working repository, any development to your own repo does
                not need any blueprint, specification or bugs against Neutron. However, if your
                project is a part of the Neutron Stadium effort, you are expected to
                participate in the principles of the Four Opens, meaning your design should be
                done in the open. Thus, it is encouraged to file documentation for changes in
                your own repository.</paragraph>
            <paragraph>If your code is hosted on git.openstack.org then the gerrit review system is
                automatically provided. Contributors should follow the review guidelines
                similar to those of Neutron. However, you as the maintainer have the
                flexibility to choose who can approve/merge changes in your own repo.</paragraph>
            <paragraph>It is recommended (but not required,
                see <reference internal="True" refuri="policies/thirdparty-ci"><inline classes="doc">policies</inline></reference>)
                that you set up a third-party CI system. This will provide a vehicle for
                checking the third-party code against Neutron changes. See <reference name="Testing and Continuous Integration" refid="testing-and-continuous-integration">Testing and
                    Continuous Integration</reference> below for more detailed recommendations.</paragraph>
            <paragraph>Design documents can still be supplied in form of Restructured Text (RST)
                documents, within the same third-party library repo. If changes to the common
                Neutron code are required, an <reference internal="True" refuri="policies/blueprints#request-for-feature-enhancement"><inline classes="std std-ref">RFE</inline></reference>
                may need to be filed. However, every case is different and you are invited to
                seek guidance from Neutron core reviewers about what steps to follow.</paragraph>
        </section>
        <section ids="testing-and-continuous-integration" names="testing\ and\ continuous\ integration">
            <title>Testing and Continuous Integration</title>
            <paragraph>The following strategies are recommendations only, since third-party CI testing
                is not an enforced requirement. However, these strategies are employed by the
                majority of the plugin/driver contributors that actively participate in the
                Neutron development community, since they have learned from experience how
                quickly their code can fall out of sync with the rapidly changing Neutron core
                code base.</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>You should run unit tests in your own external library (e.g. on
                        git.openstack.org where Jenkins setup is for free).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Your third-party CI should validate third-party integration with Neutron via
                        functional testing. The third-party CI is a communication mechanism. The
                        objective of this mechanism is as follows:</paragraph>
                    <bullet_list bullet="*">
                        <list_item>
                            <paragraph>it communicates to you when someone has contributed a change that
                                potentially breaks your code. It is then up to you maintaining the affected
                                plugin/driver to determine whether the failure is transient or real, and
                                resolve the problem if it is.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>it communicates to a patch author that they may be breaking a plugin/driver.
                                If they have the time/energy/relationship with the maintainer of the
                                plugin/driver in question, then they can (at their discretion) work to
                                resolve the breakage.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>it communicates to the community at large whether a given plugin/driver
                                is being actively maintained.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>A maintainer that is perceived to be responsive to failures in their
                                third-party CI jobs is likely to generate community goodwill.</paragraph>
                        </list_item>
                    </bullet_list>
                    <paragraph>It is worth noting that if the plugin/driver repository is hosted on
                        git.openstack.org, due to current openstack-infra limitations, it is not
                        possible to have third-party CI systems participating in the gate pipeline
                        for the repo. This means that the only validation provided during the merge
                        process to the repo is through unit tests. Post-merge hooks can still be
                        exploited to provide third-party CI feedback, and alert you of potential
                        issues. As mentioned above, third-party CI systems will continue to validate
                        Neutron core commits. This will allow them to detect when incompatible
                        changes occur, whether they are in Neutron or in the third-party repo.</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="defect-management" names="defect\ management">
            <title>Defect Management</title>
            <paragraph>Bugs affecting third-party code should <emphasis>not</emphasis> be filed in the Neutron project on
                launchpad. Bug tracking can be done in any system you choose, but by creating a
                third-party project in launchpad, bugs that affect both Neutron and your code
                can be more easily tracked using launchpad’s “also affects project” feature.</paragraph>
            <section ids="security-issues" names="security\ issues">
                <title>Security Issues</title>
                <paragraph>Here are some answers to how to handle security issues in your repo, taken
                    from <reference name="this openstack-dev mailing list message" refuri="http://lists.openstack.org/pipermail/openstack-dev/2015-July/068617.html">this openstack-dev mailing list message</reference><target ids="this-openstack-dev-mailing-list-message" names="this\ openstack-dev\ mailing\ list\ message" refuri="http://lists.openstack.org/pipermail/openstack-dev/2015-July/068617.html"></target>:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>How should security your issues be managed?</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>The OpenStack Vulnerability Management Team (VMT) follows a <reference name="documented process" refuri="https://security.openstack.org/vmt-process.html">documented process</reference><target ids="documented-process" names="documented\ process" refuri="https://security.openstack.org/vmt-process.html"></target> which can basically be
                    reused by any project-team when needed.</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Should the OpenStack security team be involved?</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>The OpenStack VMT directly oversees vulnerability reporting and disclosure for
                    a <reference name="subset of OpenStack source code repositories" refuri="https://wiki.openstack.org/wiki/Security_supported_projects">subset of OpenStack source code repositories</reference><target ids="subset-of-openstack-source-code-repositories" names="subset\ of\ openstack\ source\ code\ repositories" refuri="https://wiki.openstack.org/wiki/Security_supported_projects"></target>.  However, they
                    are still quite happy to answer any questions you might have about
                    vulnerability management for your own projects even if they’re not part of that
                    set. Feel free to reach out to the VMT in public or in private.</paragraph>
                <paragraph>Also, the VMT is an autonomous subgroup of the much larger <reference name="OpenStack Security project-team" refuri="http://governance.openstack.org/reference/projects/security.html">OpenStack Security
                        project-team</reference><target ids="openstack-security-project-team" names="openstack\ security\ project-team" refuri="http://governance.openstack.org/reference/projects/security.html"></target>. They’re a
                    knowledgeable bunch and quite responsive if you want to get their opinions or
                    help with security-related issues (vulnerabilities or otherwise).</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Does a CVE need to be filed?</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>It can vary widely. If a commercial distribution such as Red Hat is
                    redistributing a vulnerable version of your software, then they may assign one
                    anyway even if you don’t request one yourself. Or the reporter may request one;
                    the reporter may even be affiliated with an organization who has already
                    assigned/obtained a CVE before they initiate contact with you.</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Do the maintainers need to publish OSSN or equivalent documents?</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>OpenStack Security Advisories (OSSA) are official publications of the OpenStack
                    VMT and only cover VMT-supported software. OpenStack Security Notes (OSSN) are
                    published by editors within the OpenStack Security project-team on more general
                    security topics and may even cover issues in non-OpenStack software commonly
                    used in conjunction with OpenStack, so it’s at their discretion as to whether
                    they would be able to accommodate a particular issue with an OSSN.</paragraph>
                <paragraph>However, these are all fairly arbitrary labels, and what really matters in the
                    grand scheme of things is that vulnerabilities are handled seriously, fixed
                    with due urgency and care, and announced widely – not just on relevant
                    OpenStack mailing lists but also preferably somewhere with broader distribution
                    like the <reference name="Open Source Security mailing list" refuri="http://oss-security.openwall.org/wiki/mailing-lists/oss-security">Open Source Security mailing list</reference><target ids="open-source-security-mailing-list" names="open\ source\ security\ mailing\ list" refuri="http://oss-security.openwall.org/wiki/mailing-lists/oss-security"></target>. The goal
                    is to get information on your vulnerabilities, mitigating measures and fixes
                    into the hands of the people using your software in a timely manner.</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Anything else to consider here?</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>The OpenStack VMT is in the process of trying to reinvent itself so that it can
                    better scale within the context of the “Big Tent.” This includes making sure
                    the policy/process documentation is more consumable and reusable even by
                    project-teams working on software outside the scope of our charter. It’s a work
                    in progress, and any input is welcome on how we can make this function well for
                    everyone.</paragraph>
            </section>
        </section>
        <section ids="backport-management-strategies" names="backport\ management\ strategies">
            <title>Backport Management Strategies</title>
            <paragraph>This section applies only to third-party maintainers who had code in the
                Neutron tree during the Kilo and earlier releases. It will be obsolete once the
                Kilo release is no longer supported.</paragraph>
            <paragraph>If a change made to out-of-tree third-party code needs to be back-ported to
                in-tree code in a stable branch, you may submit a review without a
                corresponding master branch change. The change will be evaluated by core
                reviewers for stable branches to ensure that the backport is justified and that
                it does not affect Neutron core code stability.</paragraph>
        </section>
        <section ids="devstack-integration-strategies" names="devstack\ integration\ strategies">
            <title>DevStack Integration Strategies</title>
            <paragraph>When developing and testing a new or existing plugin or driver, the aid provided
                by DevStack is incredibly valuable: DevStack can help get all the software bits
                installed, and configured correctly, and more importantly in a predictable way.
                For DevStack integration there are a few options available, and they may or may not
                make sense depending on whether you are contributing a new or existing plugin or
                driver.</paragraph>
            <paragraph>If you are contributing a new plugin, the approach to choose should be based on
                <reference name="Extras.d Hooks' externally hosted plugins" refuri="https://docs.openstack.org/devstack/latest/plugins.html#extras-d-hooks">Extras.d Hooks’ externally hosted plugins</reference><target ids="extras-d-hooks-externally-hosted-plugins" names="extras.d\ hooks'\ externally\ hosted\ plugins" refuri="https://docs.openstack.org/devstack/latest/plugins.html#extras-d-hooks"></target>.
                With the extra.d hooks, the DevStack integration is co-located with the
                third-party integration library, and it leads to the greatest level of
                flexibility when dealing with DevStack based dev/test deployments.</paragraph>
            <paragraph>One final consideration is worth making for third-party CI setups: if <reference name="Devstack Gate" refuri="https://git.openstack.org/cgit/openstack-infra/devstack-gate">Devstack
                    Gate</reference><target ids="devstack-gate" names="devstack\ gate" refuri="https://git.openstack.org/cgit/openstack-infra/devstack-gate"></target> is used,
                it does provide hook functions that can be executed at specific times of the
                devstack-gate-wrap script run.  For example, the <reference name="Neutron Functional job" refuri="https://git.openstack.org/cgit/openstack-infra/project-config/tree/jenkins/jobs/neutron.yaml">Neutron Functional job</reference><target ids="neutron-functional-job" names="neutron\ functional\ job" refuri="https://git.openstack.org/cgit/openstack-infra/project-config/tree/jenkins/jobs/neutron.yaml"></target>
                uses them. For more details see <reference name="devstack-vm-gate-wrap.sh" refuri="https://git.openstack.org/cgit/openstack-infra/devstack-gate/tree/devstack-vm-gate-wrap.sh">devstack-vm-gate-wrap.sh</reference><target ids="devstack-vm-gate-wrap-sh" names="devstack-vm-gate-wrap.sh" refuri="https://git.openstack.org/cgit/openstack-infra/devstack-gate/tree/devstack-vm-gate-wrap.sh"></target>.</paragraph>
        </section>
        <section ids="project-initial-setup" names="project\ initial\ setup">
            <title>Project Initial Setup</title>
            <paragraph>The how-to below assumes that the third-party library will be hosted on
                git.openstack.org. This lets you tap in the entire OpenStack CI infrastructure
                and can be a great place to start from to contribute your new or existing
                driver/plugin. The list of steps below are summarized version of what you can
                find on <reference refuri="http://docs.openstack.org/infra/manual/creators.html">http://docs.openstack.org/infra/manual/creators.html</reference>. They are meant to
                be the bare minimum you have to complete in order to get you off the ground.</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>Create a public repository: this can be a personal git.openstack.org repo or any
                        publicly available git repo, e.g. <literal>https://github.com/john-doe/foo.git</literal>. This
                        would be a temporary buffer to be used to feed the one on git.openstack.org.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Initialize the repository: if you are starting afresh, you may <emphasis>optionally</emphasis>
                        want to use cookiecutter to get a skeleton project. You can learn how to use
                        cookiecutter on <reference refuri="https://git.openstack.org/cgit/openstack-dev/cookiecutter">https://git.openstack.org/cgit/openstack-dev/cookiecutter</reference>.
                        If you want to build the repository from an existing Neutron module, you may
                        want to skip this step now, build the history first (next step), and come back
                        here to initialize the remainder of the repository with other files being
                        generated by the cookiecutter (like tox.ini, setup.cfg, setup.py, etc.).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Create a repository on git.openstack.org. For
                        this you need the help of the OpenStack infra team. It is worth noting that
                        you only get one shot at creating the repository on git.openstack.org. This
                        is the time you get to choose whether you want to start from a clean slate,
                        or you want to import the repo created during the previous step. In the
                        latter case, you can do so by specifying the upstream section for your
                        project in project-config/gerrit/project.yaml.  Steps are documented on the
                        <reference name="Repository Creator's Guide" refuri="http://docs.openstack.org/infra/manual/creators.html">Repository Creator’s Guide</reference><target ids="repository-creator-s-guide" names="repository\ creator's\ guide" refuri="http://docs.openstack.org/infra/manual/creators.html"></target>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Ask for a Launchpad user to be assigned to the core team created. Steps are
                        documented in <reference name="this section" refuri="http://docs.openstack.org/infra/manual/creators.html#update-the-gerrit-group-members">this section</reference><target ids="this-section" names="this\ section" refuri="http://docs.openstack.org/infra/manual/creators.html#update-the-gerrit-group-members"></target>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Fix, fix, fix: at this point you have an external base to work on. You can
                        develop against the new git.openstack.org project, the same way you work with
                        any other OpenStack project: you have pep8, docs, and python27 CI jobs that
                        validate your patches when posted to Gerrit. For instance, one thing you
                        would need to do is to define an entry point for your plugin or driver in
                        your own setup.cfg similarly as to how it is done in the <reference name="setup.cfg for ODL" refuri="https://git.openstack.org/cgit/openstack/networking-odl/tree/setup.cfg#n31">setup.cfg for ODL</reference><target ids="setup-cfg-for-odl" names="setup.cfg\ for\ odl" refuri="https://git.openstack.org/cgit/openstack/networking-odl/tree/setup.cfg#n31"></target>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Define an entry point for your plugin or driver in setup.cfg</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Create third-party CI account: if you do not already have one, follow
                        instructions for <reference name="third-party CI" refuri="http://docs.openstack.org/infra/system-config/third_party.html">third-party CI</reference><target ids="third-party-ci" names="third-party\ ci" refuri="http://docs.openstack.org/infra/system-config/third_party.html"></target> to get
                        one.</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="internationalization-support" names="internationalization\ support">
            <title>Internationalization support</title>
            <paragraph>OpenStack is committed to broad international support.
                Internationalization (I18n) is one of important areas to make OpenStack ubiquitous.
                Each project is recommended to support i18n.</paragraph>
            <paragraph>This section describes how to set up translation support.
                The description in this section uses the following variables:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>repository : <literal>openstack/${REPOSITORY}</literal> (e.g., <literal>openstack/networking-foo</literal>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph>top level python path : <literal>${MODULE_NAME}</literal> (e.g., <literal>networking_foo</literal>)</paragraph>
                </list_item>
            </bullet_list>
            <section ids="oslo-i18n" names="oslo.i18n">
                <title>oslo.i18n</title>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>Each subproject repository should have its own oslo.i18n integration
                            wrapper module <literal>${MODULE_NAME}/_i18n.py</literal>. The detail is found at
                            <reference refuri="https://docs.openstack.org/oslo.i18n/latest/usage.html">https://docs.openstack.org/oslo.i18n/latest/usage.html</reference>.</paragraph>
                        <note>
                            <paragraph><strong>DOMAIN</strong> name should match your <strong>module</strong> name <literal>${MODULE_NAME}</literal>.</paragraph>
                        </note>
                    </list_item>
                    <list_item>
                        <paragraph>Import <literal>_()</literal> from your <literal>${MODULE_NAME}/_i18n.py</literal>.</paragraph>
                        <warning>
                            <paragraph>Do not use <literal>_()</literal> in the builtins namespace which is
                                registered by <strong>gettext.install()</strong> in <literal>neutron/__init__.py</literal>.
                                It is now deprecated as described in oslo.18n documentation.</paragraph>
                        </warning>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="setting-up-translation-support" names="setting\ up\ translation\ support">
                <title>Setting up translation support</title>
                <paragraph>You need to create or edit the following files to start translation support:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>setup.cfg</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>babel.cfg</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>We have a good example for an oslo project at
                    <reference refuri="https://review.openstack.org/#/c/98248/">https://review.openstack.org/#/c/98248/</reference>.</paragraph>
                <paragraph>Add the following to <literal>setup.cfg</literal>:</paragraph>
                <literal_block xml:space="preserve">[extract_messages]
keywords = _ gettext ngettext l_ lazy_gettext
mapping_file = babel.cfg
output_file = ${MODULE_NAME}/locale/${MODULE_NAME}.pot

[compile_catalog]
directory = ${MODULE_NAME}/locale
domain = ${MODULE_NAME}

[update_catalog]
domain = ${MODULE_NAME}
output_dir = ${MODULE_NAME}/locale
input_file = ${MODULE_NAME}/locale/${MODULE_NAME}.pot</literal_block>
                <paragraph>Note that <literal>${MODULE_NAME}</literal> is used in all names.</paragraph>
                <paragraph>Create <literal>babel.cfg</literal> with the following contents:</paragraph>
                <literal_block xml:space="preserve">[python: **.py]</literal_block>
            </section>
            <section ids="enable-translation" names="enable\ translation">
                <title>Enable Translation</title>
                <paragraph>To update and import translations, you need to make a change in project-config.
                    A good example is found at <reference refuri="https://review.openstack.org/#/c/224222/">https://review.openstack.org/#/c/224222/</reference>.
                    After doing this, the necessary jobs will be run and push/pull a
                    message catalog to/from the translation infrastructure.</paragraph>
            </section>
        </section>
        <section ids="integrating-with-the-neutron-system" names="integrating\ with\ the\ neutron\ system">
            <title>Integrating with the Neutron system</title>
            <section ids="configuration-files" names="configuration\ files">
                <title>Configuration Files</title>
                <paragraph>The <literal>data_files</literal> in the <literal>[files]</literal> section of <literal>setup.cfg</literal> of Neutron shall
                    not contain any third-party references. These shall be located in the same
                    section of the third-party repo’s own <literal>setup.cfg</literal> file.</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>Note: Care should be taken when naming sections in configuration files. When
                            the Neutron service or an agent starts, oslo.config loads sections from all
                            specified config files. This means that if a section [foo] exists in multiple
                            config files, duplicate settings will collide. It is therefore recommended to
                            prefix section names with a third-party string, e.g. [vendor_foo].</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Since Mitaka, configuration files are not maintained in the git repository but
                    should be generated as follows:</paragraph>
                <literal_block xml:space="preserve">``tox -e genconfig``</literal_block>
                <paragraph>If a ‘tox’ environment is unavailable, then you can run the following script
                    instead to generate the configuration files:</paragraph>
                <literal_block xml:space="preserve">./tools/generate_config_file_samples.sh</literal_block>
                <paragraph>It is advised that subprojects do not keep their configuration files in their
                    respective trees and instead generate them using a similar approach as Neutron
                    does.</paragraph>
                <definition_list>
                    <definition_list_item>
                        <term><strong>ToDo: Inclusion in OpenStack documentation?</strong></term>
                        <definition>
                            <paragraph>Is there a recommended way to have third-party config options listed in the
                                configuration guide in docs.openstack.org?</paragraph>
                        </definition>
                    </definition_list_item>
                </definition_list>
            </section>
            <section ids="database-models-and-migrations" names="database\ models\ and\ migrations">
                <title>Database Models and Migrations</title>
                <paragraph>A third-party repo may contain database models for its own tables. Although
                    these tables are in the Neutron database, they are independently managed
                    entirely within the third-party code. Third-party code shall <strong>never</strong> modify
                    neutron core tables in any way.</paragraph>
                <paragraph>Each repo has its own <emphasis>expand</emphasis> and <emphasis>contract</emphasis> <reference name="alembic migration branches" refuri="alembic_migrations.html#migration-branches">alembic migration branches</reference><target ids="alembic-migration-branches" names="alembic\ migration\ branches" refuri="alembic_migrations.html#migration-branches"></target>. A third-party repo’s alembic
                    migration branches may operate only on tables that are owned by the repo.</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>Note: Care should be taken when adding new tables. To prevent collision of
                            table names it is <strong>required</strong> to prefix them with a vendor/plugin string.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Note: A third-party maintainer may opt to use a separate database for their
                            tables. This may complicate cases where there are foreign key constraints
                            across schemas for DBMS that do not support this well. Third-party maintainer
                            discretion advised.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>The database tables owned by a third-party repo can have references to fields
                    in neutron core tables. However, the alembic branch for a plugin/driver repo
                    shall never update any part of a table that it does not own.</paragraph>
                <paragraph><strong>Note: What happens when a referenced item changes?</strong></paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph><strong>Q:</strong> If a driver’s table has a reference (for example a foreign key) to a
                            neutron core table, and the referenced item is changed in neutron, what
                            should you do?</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>A:</strong> Fortunately, this should be an extremely rare occurrence. Neutron core
                            reviewers will not allow such a change unless there is a very carefully
                            thought-out design decision behind it. That design will include how to
                            address any third-party code affected. (This is another good reason why you
                            should stay actively involved with the Neutron developer community.)</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>The <literal>neutron-db-manage</literal> alembic wrapper script for neutron detects alembic
                    branches for installed third-party repos, and the upgrade command automatically
                    applies to all of them. A third-party repo must register its alembic migrations
                    at installation time. This is done by providing an entrypoint in setup.cfg as
                    follows:</paragraph>
                <paragraph>For a third-party repo named <literal>networking-foo</literal>, add the alembic_migrations
                    directory as an entrypoint in the <literal>neutron.db.alembic_migrations</literal> group:</paragraph>
                <literal_block xml:space="preserve">[entry_points]
neutron.db.alembic_migrations =
    networking-foo = networking_foo.db.migration:alembic_migrations</literal_block>
                <definition_list>
                    <definition_list_item>
                        <term><strong>ToDo: neutron-db-manage autogenerate</strong></term>
                        <definition>
                            <paragraph>The alembic autogenerate command needs to support branches in external
                                repos. Bug #1471333 has been filed for this.</paragraph>
                        </definition>
                    </definition_list_item>
                </definition_list>
            </section>
            <section ids="db-model-migration-testing" names="db\ model/migration\ testing">
                <title>DB Model/Migration Testing</title>
                <paragraph>Here is a <reference internal="True" refuri="testing/template_model_sync_test"><inline classes="doc">template functional test</inline></reference>
                    third-party maintainers can use to develop tests for model-vs-migration sync in
                    their repos. It is recommended that each third-party CI sets up such a test,
                    and runs it regularly against Neutron master.</paragraph>
            </section>
            <section ids="entry-points" names="entry\ points">
                <title>Entry Points</title>
                <paragraph>The <reference name="Python setuptools" refuri="https://pythonhosted.org/setuptools">Python setuptools</reference><target ids="python-setuptools" names="python\ setuptools" refuri="https://pythonhosted.org/setuptools"></target> installs all
                    entry points for packages in one global namespace for an environment. Thus each
                    third-party repo can define its package’s own <literal>[entry_points]</literal> in its own
                    <literal>setup.cfg</literal> file.</paragraph>
                <paragraph>For example, for the <literal>networking-foo</literal> repo:</paragraph>
                <literal_block xml:space="preserve">[entry_points]
console_scripts =
    neutron-foo-agent = networking_foo.cmd.eventlet.agents.foo:main
neutron.core_plugins =
    foo_monolithic = networking_foo.plugins.monolithic.plugin:FooPluginV2
neutron.service_plugins =
    foo_l3 = networking_foo.services.l3_router.l3_foo:FooL3ServicePlugin
neutron.ml2.type_drivers =
    foo_type = networking_foo.plugins.ml2.drivers.foo:FooType
neutron.ml2.mechanism_drivers =
    foo_ml2 = networking_foo.plugins.ml2.drivers.foo:FooDriver
neutron.ml2.extension_drivers =
    foo_ext = networking_foo.plugins.ml2.drivers.foo:FooExtensionDriver</literal_block>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>Note: It is advisable to include <literal>foo</literal> in the names of these entry points to
                            avoid conflicts with other third-party packages that may get installed in the
                            same environment.</paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="api-extensions" names="api\ extensions">
                <title>API Extensions</title>
                <paragraph>Extensions can be loaded in two ways:</paragraph>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>Use the <literal>append_api_extensions_path()</literal> library API. This method is defined
                            in <literal>neutron/api/extensions.py</literal> in the neutron tree.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Leverage the <literal>api_extensions_path</literal> config variable when deploying. See the
                            example config file <literal>etc/neutron.conf</literal> in the neutron tree where this
                            variable is commented.</paragraph>
                    </list_item>
                </enumerated_list>
            </section>
            <section ids="service-providers" names="service\ providers">
                <title>Service Providers</title>
                <paragraph>If your project uses service provider(s) the same way VPNAAS and LBAAS do, you
                    specify your service provider in your <literal>project_name.conf</literal> file like so:</paragraph>
                <literal_block xml:space="preserve">[service_providers]
# Must be in form:
# service_provider=&lt;service_type&gt;:&lt;name&gt;:&lt;driver&gt;[:default][,...]</literal_block>
                <paragraph>In order for Neutron to load this correctly, make sure you do the following in
                    your code:</paragraph>
                <literal_block xml:space="preserve">from neutron.db import servicetype_db
service_type_manager = servicetype_db.ServiceTypeManager.get_instance()
service_type_manager.add_provider_configuration(
    YOUR_SERVICE_TYPE,
    pconf.ProviderConfiguration(YOUR_SERVICE_MODULE))</literal_block>
                <paragraph>This is typically required when you instantiate your service plugin class.</paragraph>
            </section>
            <section ids="interface-drivers" names="interface\ drivers">
                <title>Interface Drivers</title>
                <paragraph>Interface (VIF) drivers for the reference implementations are defined in
                    <literal>neutron/agent/linux/interface.py</literal>. Third-party interface drivers shall be
                    defined in a similar location within their own repo.</paragraph>
                <paragraph>The entry point for the interface driver is a Neutron config option. It is up to
                    the installer to configure this item in the <literal>[default]</literal> section. For example:</paragraph>
                <literal_block xml:space="preserve">[default]
interface_driver = networking_foo.agent.linux.interface.FooInterfaceDriver</literal_block>
                <definition_list>
                    <definition_list_item>
                        <term><strong>ToDo: Interface Driver port bindings.</strong></term>
                        <definition>
                            <paragraph><literal>VIF_TYPE_*</literal> constants in <literal>neutron_lib/api/definitions/portbindings.py</literal> should be
                                moved from neutron core to the repositories where their drivers are
                                implemented. We need to provide some config or hook mechanism for VIF types
                                to be registered by external interface drivers. For Nova, selecting the VIF
                                driver can be done outside of
                                Neutron (using the new <reference name="os-vif python library" refuri="https://review.openstack.org/193668">os-vif python library</reference><target ids="os-vif-python-library" names="os-vif\ python\ library" refuri="https://review.openstack.org/193668"></target>?). Armando and Akihiro to discuss.</paragraph>
                        </definition>
                    </definition_list_item>
                </definition_list>
            </section>
            <section ids="rootwrap-filters" names="rootwrap\ filters">
                <title>Rootwrap Filters</title>
                <paragraph>If a third-party repo needs a rootwrap filter for a command that is not used by
                    Neutron core, then the filter shall be defined in the third-party repo.</paragraph>
                <paragraph>For example, to add a rootwrap filters for commands in repo <literal>networking-foo</literal>:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>In the repo, create the file:
                            <literal>etc/neutron/rootwrap.d/foo.filters</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>In the repo’s <literal>setup.cfg</literal> add the filters to data_files:</paragraph>
                        <literal_block xml:space="preserve">[files]
data_files =
    etc/neutron/rootwrap.d =
        etc/neutron/rootwrap.d/foo.filters</literal_block>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="extending-python-neutronclient" names="extending\ python-neutronclient">
                <title>Extending python-neutronclient</title>
                <paragraph>The maintainer of a third-party component may wish to add extensions to the
                    Neutron CLI client. Thanks to <reference refuri="https://review.openstack.org/148318">https://review.openstack.org/148318</reference> this can now
                    be accomplished. See <reference name="Client Command Extensions" refuri="client_command_extensions.html">Client Command Extensions</reference><target ids="client-command-extensions" names="client\ command\ extensions" refuri="client_command_extensions.html"></target>.</paragraph>
            </section>
            <section ids="other-repo-split-items" names="other\ repo-split\ items">
                <title>Other repo-split items</title>
                <paragraph>(These are still TBD.)</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>Splitting policy.json? <strong>ToDo</strong> Armando will investigate.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Generic instructions (or a template) for installing an out-of-tree plugin or
                            driver for Neutron. Possibly something for the networking guide, and/or a
                            template that plugin/driver maintainers can modify and include with their
                            package.</paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
    </section>
</document>
