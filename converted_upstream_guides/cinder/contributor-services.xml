<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook">
  <title>Services, Managers and Drivers</title>
  <para>The responsibilities of Services, Managers, and Drivers, can be a bit confusing to people that are new to cinder.  This document attempts to outline the division of responsibilities to make understanding the system a little bit easier.</para>
  <para>Currently, Managers and Drivers are specified by flags and loaded using utils.load_object().  This method allows for them to be implemented as singletons, classes, modules or objects.  As long as the path specified by the flag leads to an object (or a callable that returns an object) that responds to getattr, it should work as a manager or driver.</para>
  <section>
    <title>The <xref linkend="module-cinder.service"/> Module</title>
    <para>Generic Node base class for all workers that run on hosts.</para>
  </section>
  <section>
    <title>The <xref linkend="module-cinder.manager"/> Module</title>
    <para>Base Manager class.</para>
    <para>Managers are responsible for a certain aspect of the system.  It is a logical
                grouping of code relating to a portion of the system.  In general other
                components should be using the manager to make changes to the components that
                it is responsible for.</para>
    <para>For example, other components that need to deal with volumes in some way,
                should do so by calling methods on the VolumeManager instead of directly
                changing fields in the database.  This allows us to keep all of the code
                relating to volumes in the same place.</para>
    <para>We have adopted a basic strategy of Smart managers and dumb data, which means
                rather than attaching methods to data objects, components should call manager
                methods that act on the data.</para>
    <para>Methods on managers that can be executed locally should be called directly. If
                a particular method must execute on a remote host, this should be done via rpc
                to the service that wraps the manager</para>
    <para>Managers should be responsible for most of the db access, and
                non-implementation specific data.  Anything implementation specific that canâ€™t
                be generalized should be done by the Driver.</para>
    <para>In general, we prefer to have one manager with multiple drivers for different
                implementations, but sometimes it makes sense to have multiple managers.  You
                can think of it this way: Abstract different overall strategies at the manager
                level(FlatNetwork vs VlanNetwork), and different implementations at the driver
                level(LinuxNetDriver vs CiscoNetDriver).</para>
    <para>Managers will often provide methods for initial setup of a host or periodic
                tasks to a wrapping service.</para>
    <para>This module provides Manager, a base class for managers.</para>
  </section>
  <section>
    <title>Implementation-Specific Drivers</title>
    <para>A manager will generally load a driver for some of its tasks. The driver is responsible for specific implementation details.  Anything running shell commands on a host, or dealing with other non-python code should probably be happening in a driver.</para>
    <para>Drivers should minimize touching the database, although it is currently acceptable for implementation specific data. This may be reconsidered at some point.</para>
    <para>It usually makes sense to define an Abstract Base Class for the specific driver (i.e. VolumeDriver), to define the methods that a different driver would need to implement.</para>
  </section>
</section>
