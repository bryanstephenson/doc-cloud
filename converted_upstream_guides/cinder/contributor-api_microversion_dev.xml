<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook">
  <title>API Microversions</title>
  <section>
    <title>Background</title>
    <para>Cinder uses a framework we called ‘API Microversions’ for allowing changes
                to the API while preserving backward compatibility. The basic idea is
                that a user has to explicitly ask for their request to be treated with
                a particular version of the API. So breaking changes can be added to
                the API without breaking users who don’t specifically ask for it. This
                is done with an HTTP header <literal>OpenStack-API-Version</literal> which
                is a monotonically increasing semantic version number starting from
                <literal>3.0</literal>.</para>
    <para>Each OpenStack service that uses microversions will share this header, so
                the Volume service will need to prefix the semantic version number with the
                word <literal>volume</literal>:</para>
    <screen>OpenStack-API-Version: volume 3.0</screen>
    <para>If a user makes a request without specifying a version, they will get
                the <literal>DEFAULT_API_VERSION</literal> as defined in
                <literal>cinder/api/openstack/api_version_request.py</literal>. This value is currently <literal>3.0</literal>
                and is expected to remain so for quite a long time.</para>
    <para>The Nova project was the first to implement microversions. For full
                details please read Nova’s <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://git.openstack.org/cgit/openstack/nova-specs/tree/specs/kilo/implemented/api-microversions.rst">Kilo spec for microversions</link></para>
  </section>
  <section>
    <title>When do I need a new Microversion?</title>
    <para>A microversion is needed when the contract to the user is
                changed. The user contract covers many kinds of information such as:</para>
    <itemizedlist>
      <listitem>
        <para>the Request</para>
        <itemizedlist>
          <listitem>
            <para>the list of resource URLs which exist on the server</para>
            <para>Example: adding a new shares/{ID}/foo which didn’t exist in a
                                previous version of the code</para>
          </listitem>
          <listitem>
            <para>the list of query parameters that are valid on URLs</para>
            <para>Example: adding a new parameter <literal>is_yellow</literal> servers/{ID}?is_yellow=True</para>
          </listitem>
          <listitem>
            <para>the list of query parameter values for non free form fields</para>
            <para>Example: parameter filter_by takes a small set of constants/enums “A”,
                                “B”, “C”. Adding support for new enum “D”.</para>
          </listitem>
          <listitem>
            <para>new headers accepted on a request</para>
          </listitem>
        </itemizedlist>
      </listitem>
      <listitem>
        <para>the Response</para>
        <itemizedlist>
          <listitem>
            <para>the list of attributes and data structures returned</para>
            <para>Example: adding a new attribute ‘locked’: True/False to the output
                                of shares/{ID}</para>
          </listitem>
          <listitem>
            <para>the allowed values of non free form fields</para>
            <para>Example: adding a new allowed <literal>status</literal> to shares/{ID}</para>
          </listitem>
          <listitem>
            <para>the list of status codes allowed for a particular request</para>
            <para>Example: an API previously could return 200, 400, 403, 404 and the
                                change would make the API now also be allowed to return 409.</para>
          </listitem>
          <listitem>
            <para>changing a status code on a particular response</para>
            <para>Example: changing the return code of an API from 501 to 400.</para>
          </listitem>
          <listitem>
            <para>new headers returned on a response</para>
          </listitem>
        </itemizedlist>
      </listitem>
    </itemizedlist>
    <para>The following flow chart attempts to walk through the process of “do
                we need a microversion”.</para>
    <para>
      <emphasis role="bold">Footnotes</emphasis>
    </para>
    <para>[1] - When fixing 500 errors that previously caused stack traces, try
                to map the new error into the existing set of errors that API call
                could previously return (400 if nothing else is appropriate). Changing
                the set of allowed status codes from a request is changing the
                contract, and should be part of a microversion.</para>
    <para>The reason why we are so strict on contract is that we’d like
                application writers to be able to know, for sure, what the contract is
                at every microversion in Cinder. If they do not, they will need to write
                conditional code in their application to handle ambiguities.</para>
    <para>When in doubt, consider application authors. If it would work with no
                client side changes on both Cinder versions, you probably don’t need a
                microversion. If, on the other hand, there is any ambiguity, a
                microversion is probably needed.</para>
  </section>
  <section>
    <title>In Code</title>
    <para>In <literal>cinder/api/openstack/wsgi.py</literal> we define an <literal>@api_version</literal> decorator
                which is intended to be used on top-level Controller methods. It is
                not appropriate for lower-level methods. Some examples:</para>
    <section>
      <title>Adding a new API method</title>
      <para>In the controller class:</para>
      <screen>@wsgi.Controller.api_version("3.4")
def my_api_method(self, req, id):
    ....</screen>
      <para>This method would only be available if the caller had specified an
                    <literal>OpenStack-API-Version</literal> of &gt;= <literal>3.4</literal>. If they had specified a
                    lower version (or not specified it and received the default of <literal>3.1</literal>)
                    the server would respond with <literal>HTTP/404</literal>.</para>
    </section>
    <section>
      <title>Removing an API method</title>
      <para>In the controller class:</para>
      <screen>@wsgi.Controller.api_version("3.1", "3.4")
def my_api_method(self, req, id):
    ....</screen>
      <para>This method would only be available if the caller had specified an
                    <literal>OpenStack-API-Version</literal> of &lt;= <literal>3.4</literal>, and &gt;= <literal>3.1</literal>. If <literal>3.5</literal> or later
                    is specified or if <literal>3.0</literal> or earlier (/v2 or /v1 endpoint), the server will
                    respond with <literal>HTTP/404</literal></para>
    </section>
    <section>
      <title>Changing a method’s behaviour</title>
      <para>In the controller class:</para>
      <screen>@wsgi.Controller.api_version("3.1", "3.3")
def my_api_method(self, req, id):
    .... method_1 ...

@my_api_method.api_version("3.4")
def my_api_method(self, req, id):
    .... method_2 ...</screen>
      <para>If a caller specified <literal>3.1</literal>, <literal>3.2</literal> or <literal>3.3</literal> (or received the
                    default of <literal>3.1</literal>) they would see the result from <literal>method_1</literal>,
                    <literal>3.4</literal> or later <literal>method_2</literal>.</para>
      <para>We could use <literal>wsgi.Controller.api_version</literal> decorator on the second
                    <literal>my_api_method</literal> as well, but then we would have to add <literal># noqa</literal> to that
                    line to avoid failing flake8’s <literal>F811</literal> rule.  So the recommended approach is
                    to use the <literal>api_version</literal> decorator from the first method that is defined, as
                    illustrated by the example above, and then use <literal>my_api_method</literal> decorator for
                    subsequent api versions of the same method.</para>
      <para>The two methods may be different in any kind of semantics (schema validation,
                    return values, response codes, etc.).</para>
    </section>
    <section>
      <title>A method with only small changes between versions</title>
      <para>A method may have only small changes between microversions, in which
                    case you can decorate a private method:</para>
      <screen>@wsgi.Controller.api_version("3.1", "3.4")
def _version_specific_func(self, req, arg1):
    pass

@_version_specific_func.api_version(min_ver="3.5")
def _version_specific_func(self, req, arg1):
    pass

def show(self, req, id):
    .... common stuff ....
    self._version_specific_func(req, "foo")
    .... common stuff ....</screen>
    </section>
    <section>
      <title>When not using decorators</title>
      <para>When you don’t want to use the <literal>@api_version</literal> decorator on a method
                    or you want to change behaviour within a method (say it leads to
                    simpler or simply a lot less code) you can directly test for the
                    requested version with a method as long as you have access to the api
                    request object (commonly called <literal>req</literal>). Every API method has an
                    api_version_request object attached to the req object and that can be
                    used to modify behaviour based on its value:</para>
      <screen>def index(self, req):
    &lt;common code&gt;

    req_version = req.api_version_request
    if req_version.matches("3.1", "3.5"):
        ....stuff....
    elif req_version.matches("3.6", "3.10"):
        ....other stuff....
    elif req_version &gt; api_version_request.APIVersionRequest("3.10"):
        ....more stuff.....

    &lt;common code&gt;</screen>
      <para>The first argument to the matches method is the minimum acceptable version
                    and the second is maximum acceptable version. A specified version can be null:</para>
      <screen>null_version = APIVersionRequest()</screen>
      <para>If the minimum version specified is null then there is no restriction on
                    the minimum version, and likewise if the maximum version is null there
                    is no restriction the maximum version. Alternatively a one sided comparison
                    can be used as in the example above.</para>
    </section>
  </section>
  <section>
    <title>Other necessary changes</title>
    <para>If you are adding a patch which adds a new microversion, it is
                necessary to add changes to other places which describe your change:</para>
    <itemizedlist>
      <listitem>
        <para>Update <literal>REST_API_VERSION_HISTORY</literal> in
                        <literal>cinder/api/openstack/api_version_request.py</literal></para>
      </listitem>
      <listitem>
        <para>Update <literal>_MAX_API_VERSION</literal> in
                        <literal>cinder/api/openstack/api_version_request.py</literal></para>
      </listitem>
      <listitem>
        <para>Add a verbose description to
                        <literal>cinder/api/openstack/rest_api_version_history.rst</literal>.  There should
                        be enough information that it could be used by the docs team for
                        release notes.</para>
      </listitem>
      <listitem>
        <para>Update the expected versions in affected tests.</para>
      </listitem>
    </itemizedlist>
  </section>
  <section>
    <title>Allocating a microversion</title>
    <para>If you are adding a patch which adds a new microversion, it is
                necessary to allocate the next microversion number. Except under
                extremely unusual circumstances and this would have been mentioned in
                the blueprint for the change, the minor number of <literal>_MAX_API_VERSION</literal>
                will be incremented. This will also be the new microversion number for
                the API change.</para>
    <para>It is possible that multiple microversion patches would be proposed in
                parallel and the microversions would conflict between patches.  This
                will cause a merge conflict. We don’t reserve a microversion for each
                patch in advance as we don’t know the final merge order. Developers
                may need over time to rebase their patch calculating a new version
                number as above based on the updated value of <literal>_MAX_API_VERSION</literal>.</para>
  </section>
  <section>
    <title>Testing Microversioned API Methods</title>
    <para>Unit tests for microversions should be put in cinder/tests/unit/api/v3/ .
                Since all existing functionality is tested in cinder/tests/unit/api/v2,
                these unit tests are not replicated in …/v3, and only new functionality
                needs to be place in the …/v3/directory.</para>
    <para>Testing a microversioned API method is very similar to a normal controller
                method test, you just need to add the <literal>OpenStack-API-Version</literal>
                header, for example:</para>
    <screen>req = fakes.HTTPRequest.blank('/testable/url/endpoint')
req.headers['OpenStack-API-Version'] = 'volume 3.6'
req.api_version_request = api_version.APIVersionRequest('3.6')

controller = controller.TestableController()

res = controller.index(req)
... assertions about the response ...</screen>
  </section>
</section>
