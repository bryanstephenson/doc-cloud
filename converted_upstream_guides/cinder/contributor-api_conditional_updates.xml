<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1">
  <title>API Races - Conditional Updates</title>
  <section>
    <title>Background</title>
    <para>On Cinder API nodes we have to check that requested action can be performed by
                checking request arguments and involved resources, and only if everything
                matches required criteria we will proceed with the RPC call to any of the other
                nodes.</para>
    <para>Checking the conditions must be done in a non racy way to ensure that already
                checked requirements don’t change while we check remaining conditions.  This is
                of utter importance, as Cinder uses resource status as a lock to prevent
                concurrent operations on a resource.</para>
    <para>An simple example of this would be extending a volume, where we first check the
                status:</para>
    <screen>ifvolume['status']!='available':</screen>
    <para>Then update the status:</para>
    <screen>self.update(context,volume,{'status':'extending'})</screen>
    <para>And finally make the RPC call:</para>
    <screen>self.volume_rpcapi.extend_volume(context,volume,new_size,reservations)</screen>
    <para>The problem is that this code would allow races, as other request could
                have already changed the volume status between us getting the value and
                updating the DB.</para>
    <para>There are multiple ways to fix this, such as:</para>
    <itemizedlist>
      <listitem>
        <para>Using a Distributed Locking Mechanism</para>
      </listitem>
      <listitem>
        <para>Using DB isolation level</para>
      </listitem>
      <listitem>
        <para>Using SQL SELECT … FOR UPDATE</para>
      </listitem>
      <listitem>
        <para>USING compare and swap mechanism in SQL query</para>
      </listitem>
    </itemizedlist>
    <para>Our tests showed that the best alternative was compare and swap and we decided
                to call this mechanism “Conditional Update” as it seemed more appropriate.</para>
  </section>
  <section>
    <title>Conditional Update</title>
    <para>Conditional Update is the mechanism we use in Cinder to prevent races when
                updating the DB.  In essence it is the SQL equivalent of an <literal>UPDATE ... FROM
... WHERE;</literal> clause</para>
    <para>It is implemented as an abstraction layer on top of SQLAlchemy ORM engine in
                our DB api layer and exposed for consumption in Cinder’s Persistent Versioned
                Objects through the <literal>conditional_update</literal> method so it can be used from any
                Versioned Object instance that has persistence (Volume, Snapshot, Backup…).</para>
    <para>Method signature is:</para>
    <screen><?dbsuse-fo font-size="8pt"?>defconditional_update(self,values,expected_values=None,filters=(),save_all=False,session=None,reflect_changes=True):</screen>
  </section>
  <section>
    <title>Basic Usage</title>
    <itemizedlist>
      <listitem>
        <para>
          <emphasis role="bold">Simple match</emphasis>
        </para>
        <para>The most basic example is doing a simple match, for example for a <literal>volume</literal>
                        variable that contains a Versioned Object Volume class instance we may want
                        to change the <literal>status</literal> to “deleting” and update the <literal>terminated_at</literal> field
                        with current UTC time only if current <literal>status</literal> is “available” and the
                        volume is not in a consistency group.</para>
        <screen><?dbsuse-fo font-size="8pt"?>values={'status':'deleting','terminated_at':timeutils.utcnow()}expected_values={'status':'available','consistencygroup_id':None}volume.conditional_update(values,expected_values)</screen>
      </listitem>
      <listitem>
        <para>
          <emphasis role="bold">Iterable match</emphasis>
        </para>
        <para>Conditions can contain not only single values, but also iterables, and the
                        conditional update mechanism will correctly handle the presence of None
                        values in the range, unlike SQL <literal>IN</literal> clause that doesn’t support <literal>NULL</literal>
                        values.</para>
        <screen><?dbsuse-fo font-size="8pt"?>values={'status':'deleting','terminated_at':timeutils.utcnow()}expected_values={'status':('available','error','error_restoring''error_extending'),'migration_status':(None,'deleting','error','success'),'consistencygroup_id':None}volume.conditional_update(values,expected_values)</screen>
      </listitem>
      <listitem>
        <para>
          <emphasis role="bold">Exclusion</emphasis>
        </para>
        <para>In some cases we’ll need to set conditions on what is <emphasis>not</emphasis> in the DB record
                        instead of what is is, for that we will use the exclusion mechanism provided
                        by the <literal>Not</literal> class in all persistent objects.  This class accepts single
                        values as well as iterables.</para>
        <screen><?dbsuse-fo font-size="8pt"?>values={'status':'deleting','terminated_at':timeutils.utcnow()}expected_values={'attach_status':volume.Not('attached'),'status':('available','error','error_restoring''error_extending'),'migration_status':(None,'deleting','error','success'),'consistencygroup_id':None}volume.conditional_update(values,expected_values)</screen>
      </listitem>
      <listitem>
        <para>
          <emphasis role="bold">Filters</emphasis>
        </para>
        <para>We can use complex filters in the conditions, but these must be SQLAlchemy
                        queries/conditions and as the rest of the DB methods must be properly
                        abstracted from the API.</para>
        <para>Therefore we will create the method in cinder/db/sqlalchemy/api.py:</para>
        <screen><?dbsuse-fo font-size="8pt"?>defvolume_has_snapshots_filter():returnsql.exists().where(and_(models.Volume.id==models.Snapshot.volume_id,~models.Snapshot.deleted))</screen>
        <para>Then expose this filter through the cinder/db/api.py:</para>
        <screen>defvolume_has_snapshots_filter():returnIMPL.volume_has_snapshots_filter()</screen>
        <para>And finally used in the API (notice how we are negating the filter at the
                        API):</para>
        <screen><?dbsuse-fo font-size="8pt"?>filters=[~db.volume_has_snapshots_filter()]values={'status':'deleting','terminated_at':timeutils.utcnow()}expected_values={'attach_status':volume.Not('attached'),'status':('available','error','error_restoring''error_extending'),'migration_status':(None,'deleting','error','success'),'consistencygroup_id':None}volume.conditional_update(values,expected_values,filters)</screen>
      </listitem>
    </itemizedlist>
  </section>
  <section>
    <title>Returning Errors</title>
    <para>The most important downside of using conditional updates to remove API races is
                the inherent uncertainty of the cause of failure resulting in more generic
                error messages.</para>
    <para>When we use the <literal>conditional_update</literal> method we’ll use returned value to
                determine the success of the operation, as a value of 0 indicates that no rows
                have been updated and the conditions were not met.  But we don’t know which
                one, or which ones, were the cause of the failure.</para>
    <para>There are 2 approaches to this issue:</para>
    <itemizedlist>
      <listitem>
        <para>On failure we go one by one checking the conditions and return the first one
                        that fails.</para>
      </listitem>
      <listitem>
        <para>We return a generic error message indicating all conditions that must be met
                        for the operation to succeed.</para>
      </listitem>
    </itemizedlist>
    <para>It was decided that we would go with the second approach, because even though
                the first approach was closer to what we already had and would give a better
                user experience, it had considerable implications such as:</para>
    <itemizedlist>
      <listitem>
        <para>More code was needed to do individual checks making operations considerable
                        longer and less readable.  This was greatly alleviated using helper methods
                        to return the errors.</para>
      </listitem>
      <listitem>
        <para>Higher number of DB queries required to determine failure cause.</para>
      </listitem>
      <listitem>
        <para>Since there could be races because DB contents could be changed between the
                        failed update and the follow up queries that checked the values for the
                        specific error, a loop would be needed to make sure that either the
                        conditional update succeeds or one of the condition checks fails.</para>
      </listitem>
      <listitem>
        <para>Having such a loop means that a small error in the code could lead to an
                        endless loop in a production environment.  This coding error could be an
                        incorrect conditional update filter that would always fail or a missing or
                        incorrect condition that checked for the specific issue to return the error.</para>
      </listitem>
    </itemizedlist>
    <para>A simple example of a generic error can be found in <literal>begin_detaching</literal> code:</para>
    <screen><?dbsuse-fo font-size="8pt"?>@wrap_check_policydefbegin_detaching(self,context,volume):# If we are in the middle of a volume migration, we don't want the# user to see that the volume is 'detaching'. Having# 'migration_status' set will have the same effect internally.expected={'status':'in-use','attach_status':'attached','migration_status':self.AVAILABLE_MIGRATION_STATUS}result=volume.conditional_update({'status':'detaching'},expected)ifnot(resultorself._is_volume_migrating(volume)):msg=_("Unable to detach volume. Volume status must be 'in-use' ""and attach_status must be 'attached' to detach.")LOG.error(msg)raiseexception.InvalidVolume(reason=msg)</screen>
  </section>
  <section>
    <title>Building filters on the API</title>
    <para>SQLAlchemy filters created as mentioned above can create very powerful and
                complex conditions, but sometimes we may require a condition that, while more
                complex than the basic match and not match on the resource fields, it’s still
                quite simple.  For those cases we can create filters directly on the API using
                the <literal>model</literal> field provided in Versioned Objects.</para>
    <para>This <literal>model</literal> field is a reference to the ORM model that allows us to
                reference ORM fields.</para>
    <para>We’ll use as an example changing the <literal>status</literal> field of a backup to
                “restoring” if the backup status is “available” and the volume where we are
                going to restore the backup is also in “available” state.</para>
    <para>Joining of tables is implicit when using a model different from the one used
                for the Versioned Object instance.</para>
    <itemizedlist>
      <listitem>
        <para>
          <emphasis role="bold">As expected_values</emphasis>
        </para>
        <para>Since this is a matching case we can use <literal>expected_values</literal> argument to make
                        the condition:</para>
        <screen><?dbsuse-fo font-size="8pt"?>values={'status':'restoring'}expected_values={'status':'available',objects.Volume.model.id:volume.id,objects.Volume.model.status:'available'}</screen>
      </listitem>
      <listitem>
        <para>
          <emphasis role="bold">As filters</emphasis>
        </para>
        <para>We can also use the <literal>filters</literal> argument to achieve the same results:</para>
        <screen><?dbsuse-fo font-size="8pt"?>filters=[objects.Volume.model.id==volume.id,objects.Volume.model.status=='available']</screen>
      </listitem>
      <listitem>
        <para>
          <emphasis role="bold">Other filters</emphasis>
        </para>
        <para>If we are not doing a match for the condition the only available option will
                        be to use <literal>filters</literal> argument.  For example if we want to do a check on the
                        volume size against the backup size:</para>
        <screen><?dbsuse-fo font-size="8pt"?>filters=[objects.Volume.model.id==volume.id,objects.Volume.model.size&gt;=backup.model.size]</screen>
      </listitem>
    </itemizedlist>
  </section>
  <section>
    <title>Using DB fields for assignment</title>
    <itemizedlist>
      <listitem>
        <para>
          <emphasis role="bold">Using non modified fields</emphasis>
        </para>
        <para>Similar to the way we use the fields to specify conditions, we can also use
                        them to set values in the DB.</para>
        <para>For example when we disable a service we want to keep existing <literal>updated_at</literal>
                        field value:</para>
        <screen>values={'disabled':True,'updated_at':service.model.updated_at}</screen>
      </listitem>
      <listitem>
        <para>
          <emphasis role="bold">Using modified field</emphasis>
        </para>
        <para>In some cases we may need to use a DB field that we are also updating, for
                        example when we are updating the <literal>status</literal> but we also want to keep the old
                        value in the <literal>previous_status</literal> field.</para>
        <screen>values={'status':'retyping','previous_status':volume.model.status}</screen>
        <para>Conditional update mechanism takes into account that MySQL does not follow
                        SQL language specs and adjusts the query creation accordingly.</para>
      </listitem>
      <listitem>
        <para>
          <emphasis role="bold">Together with filters</emphasis>
        </para>
        <para>Using DB fields for assignment together with using them for values can give
                        us advanced functionality like for example increasing a quota value based on
                        current value and making sure we don’t exceed our quota limits.</para>
        <screen><?dbsuse-fo font-size="8pt"?>values={'in_use':quota.model.in_use+volume.size}filters=[quota.model.in_use&lt;=max_usage-volume.size]</screen>
      </listitem>
    </itemizedlist>
  </section>
  <section>
    <title>Conditional value setting</title>
    <para>Under certain circumstances you may not know what value should be set in the DB
                because it depends on another field or on another condition.  For those cases
                we can use the <literal>Case</literal> class present in our persistent Versioned Objects which
                implements the SQL CASE clause.</para>
    <para>The idea is simple, using <literal>Case</literal> class we can say which values to set in a
                field based on conditions and also set a default value if none of the
                conditions are True.</para>
    <variablelist>
      <varlistentry>
        <term>Conditions must be SQLAlchemy conditions, so we’ll need to use fields from the</term>
        <listitem>
          <para><literal>model</literal> attribute.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <para>For example setting the status to “maintenance” during migration if current
                status is “available” and leaving it as it was if it’s not can be done using
                the following:</para>
    <screen><?dbsuse-fo font-size="8pt"?>values={'status':volume.Case([(volume.model.status=='available','maintenance')],else_=volume.model.status)}</screen>
  </section>
  <section>
    <title>reflect_changes considerations</title>
    <para>As we’ve already mentioned <literal>conditional_update</literal> method will update Versioned
                Object instance with provided values if the row in the DB has been updated, and
                in most cases this is OK since we can set the values directly because we are
                using simple values, but there are cases where we don’t know what value we
                should set in the instance, and is in those cases where the default
                <literal>reflect_changes</literal> value of True has performance implications.</para>
    <para>There are 2 cases where Versioned Object <literal>conditional_update</literal> method doesn’t
                know the value it has to set on the Versioned Object instance, and they are
                when we use a field for assignment and when we are using the <literal>Case</literal> class,
                since in both cases the DB is the one deciding the value that will be set.</para>
    <para>In those cases <literal>conditional_update</literal> will have to retrieve the value from the
                DB using <literal>get_by_id</literal> method, and this has a performance impact and therefore
                should be avoided when possible.</para>
    <para>So the recommendation is to set <literal>reflect_changes</literal> to False when using
                <literal>Case</literal> class or using fields in the <literal>values</literal> argument if we don’t care
                about the stored value.</para>
  </section>
  <section>
    <title>Limitations</title>
    <para>We can only use functionality that works on <emphasis role="bold">all</emphasis> supported DBs, and that’s
                why we don’t allow multi table updates and will raise ProgrammingError
                exception even when the code is running against a DB engine that supports this
                functionality.</para>
    <para>This way we make sure that we don’t inadvertently add a multi table update that
                works on MySQL but will surely fail on PostgreSQL.</para>
    <para>MySQL DB engine also has some limitations that we should be aware of when
                creating our filters.</para>
    <para>One that is very common is when we are trying to check if there is a row that
                matches a specific criteria in the same table that we are updating.  For
                example, when deleting a Consistency Group we want to check that it is not
                being used as the source for a Consistency Group that is in the process of
                being created.</para>
    <para>The straightforward way of doing this is using the core exists expression and
                use an alias to differentiate general query fields and the exists subquery.
                Code would look like this:</para>
    <screen><?dbsuse-fo font-size="8pt"?>defcg_creating_from_src(cg_id):model=aliased(models.ConsistencyGroup)returnsql.exists().where(and_(~model.deleted,model.status=='creating',conditions.append(model.source_cgid==cg_id)))</screen>
    <para>While this will work in SQLite and PostgreSQL, it will not work on MySQL and an
                error will be raised when the query is executed: “You can’t specify target
                table ‘consistencygroups’ for update in FROM clause”.</para>
    <para>To solve this we have 2 options:</para>
    <itemizedlist>
      <listitem>
        <para>Create a specific query for MySQL engines using an update with a left self
                        join, which is a feature only available in MySQL.</para>
      </listitem>
      <listitem>
        <para>Use a trick -using a select subquery- that will work on all DBs.</para>
      </listitem>
    </itemizedlist>
    <para>Considering that it’s always better to have only 1 way of doing things and that
                SQLAlchemy doesn’t support MySQL’s non standard behavior we should generate
                these filters using the select subquery method like this:</para>
    <screen><?dbsuse-fo font-size="8pt"?>defcg_creating_from_src(cg_id):subq=sql.select([models.ConsistencyGroup]).where(and_(~model.deleted,model.status=='creating')).alias('cg2')returnsql.exists([subq]).where(subq.c.source_cgid==cgid)</screen>
  </section>
  <section>
    <title>Considerations for new ORM &amp; Versioned Objects</title>
    <para>Conditional update mechanism works using generic methods for getting an object
                from the DB as well as determining the model for a specific Versioned Object
                instance for field binding.</para>
    <para>These generic methods rely on some naming rules for Versioned Object classes,
                ORM classes, and get methods, so when we are creating a new ORM class and
                adding the matching Versioned Object and access methods we must be careful to
                follow these rules or at least specify exceptions if we have a good reason not
                to follow these conventions.</para>
    <para>Rules:</para>
    <itemizedlist>
      <listitem>
        <para>Versioned Object class name must be the same as the ORM class</para>
      </listitem>
      <listitem>
        <para>Get method name must be ORM class converted to snake format with postfix
                        “_get”.  For example, for <literal>Volume</literal> ORM class expected method is
                        <literal>volume_get</literal>, and for an imaginary <literal>MyORMClass</literal> it would be
                        <literal>my_orm_class_get</literal>.</para>
      </listitem>
      <listitem>
        <para>Get method must receive the <literal>context</literal> as the first argument and the <literal>id</literal>
                        as the second one, although it may accept more optional arguments.</para>
      </listitem>
    </itemizedlist>
    <para>We should avoid diverging from these rules whenever is possible, but there are
                cases where this is not possible, for example <literal>BackupImport</literal> Versioned Object
                that really uses <literal>Backup</literal> ORM class.  For cases such as this we have a way to
                set exceptions both for the generic get method and the model for a Versioned
                Object.</para>
    <para>To add exceptions for the get method we have to add a new entry to
                <literal>GET_EXCEPTIONS</literal> dictionary mapping in
                <literal>cinder.db.sqlalchemy.api._get_get_method</literal>.</para>
    <para>And for determining the model for the Versioned Object we have to add a new
                entry to <literal>VO_TO_MODEL_EXCEPTIONS</literal> dictionary mapping in
                <literal>cinder.db.sqlalchemy.api.get_model_for_versioned_object</literal>.</para>
  </section>
</section>
