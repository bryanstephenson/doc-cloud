<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1">
  <title>Storage Volumes, Disks</title>
  <note>
    <para>TODO(todd or vish): rework after iSCSI merge (see ‘Old Docs’) (todd or vish)</para>
  </note>
  <section>
    <title>The <xref linkend="module-cinder.volume.manager"/> Module</title>
    <para>Volume manager manages creating, attaching, detaching, and persistent storage.</para>
    <para>Persistent storage volumes keep their state independent of instances.  You can
                attach to an instance, terminate the instance, spawn a new instance (even
                one from a different image) and re-attach the volume with the same data
                intact.</para>
    <para>
      <emphasis role="bold">Related Flags</emphasis>
    </para>
    <variablelist>
      <varlistentry>
        <term>
          <literal/>
        </term>
        <listitem>
          <para>Bases: <xref linkend="cinder.manager.CleanableManager"/>, <xref linkend="cinder.manager.SchedulerDependentManager"/></para>
          <para>Manages attachable block storage devices.</para>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Updates db to show volume is attached.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Delete/Detach the specified attachment.</para>
                <para>Notifies the backend device that we’re detaching the specified
                                attachment instance.</para>
                <para>param: vref: Volume object associated with the attachment
                                param: attachment: Attachment reference object to remove</para>
                <para>NOTE if the attachment reference is None, we remove all existing
                                attachments for the specified volume object.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Update/Finalize an attachment.</para>
                <para>This call updates a valid attachment record to associate with a volume
                                and provide the caller with the proper connection info.  Note that
                                this call requires an <literal>attachment_ref</literal>.  It’s expected that prior to
                                this call that the volume and an attachment UUID has been reserved.</para>
                <para>param: vref: Volume object to create attachment for
                                param: connector: Connector object to use for attachment creation
                                param: attachment_ref: ID of the attachment record to update</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Uploads the specified volume to Glance.</para>
                <para>image_meta is a dictionary containing the following keys:
                                ‘id’, ‘container_format’, ‘disk_format’</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Creates the group.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Creates the group from source.</para>
                <para>The source can be a group snapshot or a source group.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Creates the group_snapshot.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Creates and exports the snapshot.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Creates the volume.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Deletes group and the volumes in the group.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Deletes group_snapshot.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Deletes and unexports snapshot.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Deletes and unexports volume.</para>
                <procedure>
                  <step>
                    <para>Delete a volume(normal case)
                                        Delete a volume and update quotas.</para>
                  </step>
                  <step>
                    <para>Delete a migration volume
                                        If deleting the volume in a migration, we want to skip
                                        quotas but we need database updates for the volume.</para>
                  </step>
                </procedure>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Updates db to show volume is detached.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Disable replication.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Enable replication.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Failover a backend to a secondary replication target.</para>
                <para>Instructs a replication capable/configured backend to failover
                                to one of it’s secondary replication targets. host=None is
                                an acceetable input, and leaves it to the driver to failover
                                to the only configured target, or to choose a target on it’s
                                own. All of the hosts volumes will be passed on to the driver
                                in order for it to determine the replicated volumes on the host,
                                if needed.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Finalize failover of this backend.</para>
                <para>When a service is clustered and replicated the failover has 2 stages,
                                one that does the failover of the volumes and another that finalizes
                                the failover of the services themselves.</para>
                <para>This method takes care of the last part and is called from the service
                                doing the failover of the volumes after finished processing the
                                volumes.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Failover a backend to a secondary replication target.</para>
                <para>Instructs a replication capable/configured backend to failover
                                to one of it’s secondary replication targets. host=None is
                                an acceetable input, and leaves it to the driver to failover
                                to the only configured target, or to choose a target on it’s
                                own. All of the hosts volumes will be passed on to the driver
                                in order for it to determine the replicated volumes on the host,
                                if needed.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Failover replication.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Completion of the failover locally or via RPC.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Freeze management plane on this backend.</para>
                <para>Basically puts the control/management plane into a
                                Read Only state.  We should handle this in the scheduler,
                                however this is provided to let the driver know in case it
                                needs/wants to do something specific on the backend.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Get capabilities of backend storage.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Perform any required initialization.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Prepare volume for connection from host represented by connector.</para>
                <para>This method calls the driver initialize_connection and returns
                                it to the caller.  The connector parameter is a dictionary with
                                information about the host that will connect to the volume in the
                                following format:</para>
                <screen>.. code:: json

  {
      'ip': ip,
      'initiator': initiator,
  }</screen>
                <para>ip: the ip address of the connecting machine</para>
                <para>initiator: the iscsi initiator name of the connecting machine.
                                This can be None if the connecting machine does not support iscsi
                                connections.</para>
                <para>driver is responsible for doing any necessary security setup and
                                returning a connection_info dictionary in the following format:</para>
                <screen>.. code:: json

  {
      'driver_volume_type': driver_volume_type,
      'data': data,
  }</screen>
                <variablelist>
                  <varlistentry>
                    <term>driver_volume_type: a string to identify the type of volume.  This</term>
                    <listitem>
                      <para>can be used by the calling code to determine the
                                            strategy for connecting to the volume. This could
                                            be ‘iscsi’, ‘rbd’, ‘sheepdog’, etc.</para>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>data: this is the data that the calling code will use to connect</term>
                    <listitem>
                      <para>to the volume. Keep in mind that this will be serialized to
                                            json in various places, so it should not contain any non-json
                                            data types.</para>
                    </listitem>
                  </varlistentry>
                </variablelist>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Return if Manager is ready to accept requests.</para>
                <para>This is to inform Service class that in case of volume driver
                                initialization failure the manager is actually down and not ready to
                                accept any requests.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Provide a means to obtain replication targets for a group.</para>
                <para>This method is used to find the replication_device config
                                info. ‘backend_id’ is a required key in ‘replication_device’.</para>
                <para>Response Example for admin:</para>
                <screen><?dbsuse-fo font-size="8pt"?>{'replication_targets':[{'backend_id':'vendor-id-1','unique_key':'val1',......},{'backend_id':'vendor-id-2','unique_key':'val2',......}]}</screen>
                <para>Response example for non-admin:</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Migrate the volume to the specified host (called on source host).</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Collect driver status and then publish.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Removes an export for a volume.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Removes an export for a snapshot.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Revert a volume to a snapshot.</para>
                <para>The process of reverting to snapshot consists of several steps:
                                1.   create a snapshot for backup (in case of data loss)
                                2.1. use driver’s specific logic to revert volume
                                2.2. try the generic way to revert volume if driver’s method is missing
                                3.   delete the backup snapshot</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Cleanup connection from host represented by connector.</para>
                <para>The format of connector is the same as for initialize_connection.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>UnFreeze management plane on this backend.</para>
                <para>Basically puts the control/management plane back into
                                a normal state.  We should handle this in the scheduler,
                                however this is provided to let the driver know in case it
                                needs/wants to do something specific on the backend.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Updates group.</para>
                <para>Update group by adding volumes to the group,
                                or removing volumes from the group.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Finalize migration process on backend device.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section>
    <title>The <xref linkend="module-cinder.volume.driver"/> Module</title>
    <para>Drivers for volumes.</para>
    <variablelist>
      <varlistentry>
        <term>
          <literal/>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Executes commands relating to Volumes.</para>
          <para>Base Driver for Cinder Volume Control Path,
                        This includes supported/required implementation
                        for API calls.  Also provides <emphasis>generic</emphasis> implementation
                        of core features like cloning, copy_image_to_volume etc,
                        this way drivers that inherit from this base class and
                        don’t offer their own impl can fall back on a general
                        solution here.</para>
          <para>Key thing to keep in mind with this driver is that it’s
                        intended that these drivers ONLY implement Control Path
                        details (create, delete, extend…), while transport or
                        data path related implementation should be a <emphasis>member object</emphasis>
                        that we call a connector.  The point here is that for example
                        don’t allow the LVM driver to implement iSCSI methods, instead
                        call whatever connector it has configured via conf file
                        (iSCSI{LIO, TGT, IET}, FC, etc).</para>
          <para>In the base class and for example the LVM driver we do this via a has-a
                        relationship and just provide an interface to the specific connector
                        methods.  How you do this in your own driver is of course up to you.</para>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Driver-specific actions after copyvolume data.</para>
                <para>This method will be called after _copy_volume_data during volume
                                migration</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Callback for volume attached to instance or host.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Driver-specific actions before copyvolume data.</para>
                <para>This method will be called before _copy_volume_data during volume
                                migration</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Clean up after an interrupted image copy.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Fetch image from image_service and write to encrypted volume.</para>
                <para>This attaches the encryptor layer when connecting to the volume.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Fetch image from image_service and write to unencrypted volume.</para>
                <para>This does not attach an encryptor layer when connecting to the volume.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Copy the volume to the specified image.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Creates a clone of the specified volume.</para>
                <para>If volume_type extra specs includes ‘replication: &lt;is&gt; True’ the
                                driver needs to create a volume replica (secondary)
                                and setup replication between the newly created volume
                                and the secondary volume.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Exports the volume.</para>
                <para>Can optionally return a Dictionary of changes
                                to the volume object to be persisted.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Exports the snapshot.</para>
                <para>Can optionally return a Dictionary of changes
                                to the snapshot object to be persisted.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Creates a group.</para>
                <para>model_update will be in this format: {‘status’: xxx, ……}.</para>
                <para>If the status in model_update is ‘error’, the manager will throw
                                an exception and it will be caught in the try-except block in the
                                manager. If the driver throws an exception, the manager will also
                                catch it in the try-except block. The group status in the db will
                                be changed to ‘error’.</para>
                <para>For a successful operation, the driver can either build the
                                model_update and return it or return None. The group status will
                                be set to ‘available’.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Creates a group from source.</para>
                <para>The source can be group_snapshot or a source_group.</para>
                <para>param volumes is a list of objects retrieved from the db. It cannot
                                be assigned to volumes_model_update. volumes_model_update is a list
                                of dictionaries. It has to be built by the driver. An entry will be
                                in this format: {‘id’: xxx, ‘status’: xxx, ……}. model_update
                                will be in this format: {‘status’: xxx, ……}.</para>
                <para>To be consistent with other volume operations, the manager will
                                assume the operation is successful if no exception is thrown by
                                the driver. For a successful operation, the driver can either build
                                the model_update and volumes_model_update and return them or
                                return None, None.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Creates a group_snapshot.</para>
                <para>param snapshots is a list of Snapshot objects. It cannot be assigned
                                to snapshots_model_update. snapshots_model_update is a list of
                                dictionaries. It has to be built by the driver. An entry will be
                                in this format: {‘id’: xxx, ‘status’: xxx, ……}. model_update
                                will be in this format: {‘status’: xxx, ……}.</para>
                <para>The driver should populate snapshots_model_update and model_update
                                and return them.</para>
                <para>The manager will check snapshots_model_update and update db accordingly
                                for each snapshot. If the driver successfully deleted some snapshots
                                but failed to delete others, it should set statuses of the snapshots
                                accordingly so that the manager can update db correctly.</para>
                <para>If the status in any entry of snapshots_model_update is ‘error’, the
                                status in model_update will be set to the same if it is not already
                                ‘error’.</para>
                <para>If the status in model_update is ‘error’, the manager will raise an
                                exception and the status of group_snapshot will be set to ‘error’ in
                                the db. If snapshots_model_update is not returned by the driver, the
                                manager will set the status of every snapshot to ‘error’ in the except
                                block.</para>
                <para>If the driver raises an exception during the operation, it will be
                                caught by the try-except block in the manager and the statuses of
                                group_snapshot and all snapshots will be set to ‘error’.</para>
                <para>For a successful operation, the driver can either build the
                                model_update and snapshots_model_update and return them or
                                return None, None. The statuses of group_snapshot and all snapshots
                                will be set to ‘available’ at the end of the manager function.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Creates a volume.</para>
                <para>Can optionally return a Dictionary of changes to the volume object to
                                be persisted.</para>
                <para>If volume_type extra specs includes
                                ‘capabilities:replication &lt;is&gt; True’ the driver
                                needs to create a volume replica (secondary), and setup replication
                                between the newly created volume and the secondary volume.
                                Returned dictionary should include:</para>
                <screen language="python">volume['replication_status'] = 'copying'
volume['replication_extended_status'] = &lt;driver specific value&gt;
volume['driver_data'] = &lt;driver specific value&gt;</screen>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Deletes a group.</para>
                <para>param volumes is a list of objects retrieved from the db. It cannot
                                be assigned to volumes_model_update. volumes_model_update is a list
                                of dictionaries. It has to be built by the driver. An entry will be
                                in this format: {‘id’: xxx, ‘status’: xxx, ……}. model_update
                                will be in this format: {‘status’: xxx, ……}.</para>
                <para>The driver should populate volumes_model_update and model_update
                                and return them.</para>
                <para>The manager will check volumes_model_update and update db accordingly
                                for each volume. If the driver successfully deleted some volumes
                                but failed to delete others, it should set statuses of the volumes
                                accordingly so that the manager can update db correctly.</para>
                <para>If the status in any entry of volumes_model_update is ‘error_deleting’
                                or ‘error’, the status in model_update will be set to the same if it
                                is not already ‘error_deleting’ or ‘error’.</para>
                <para>If the status in model_update is ‘error_deleting’ or ‘error’, the
                                manager will raise an exception and the status of the group will be
                                set to ‘error’ in the db. If volumes_model_update is not returned by
                                the driver, the manager will set the status of every volume in the
                                group to ‘error’ in the except block.</para>
                <para>If the driver raises an exception during the operation, it will be
                                caught by the try-except block in the manager. The statuses of the
                                group and all volumes in it will be set to ‘error’.</para>
                <para>For a successful operation, the driver can either build the
                                model_update and volumes_model_update and return them or
                                return None, None. The statuses of the group and all volumes
                                will be set to ‘deleted’ after the manager deletes them from db.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Deletes a group_snapshot.</para>
                <para>param snapshots is a list of objects. It cannot be assigned to
                                snapshots_model_update. snapshots_model_update is a list of of
                                dictionaries. It has to be built by the driver. An entry will be
                                in this format: {‘id’: xxx, ‘status’: xxx, ……}. model_update
                                will be in this format: {‘status’: xxx, ……}.</para>
                <para>The driver should populate snapshots_model_update and model_update
                                and return them.</para>
                <para>The manager will check snapshots_model_update and update db accordingly
                                for each snapshot. If the driver successfully deleted some snapshots
                                but failed to delete others, it should set statuses of the snapshots
                                accordingly so that the manager can update db correctly.</para>
                <para>If the status in any entry of snapshots_model_update is
                                ‘error_deleting’ or ‘error’, the status in model_update will be set to
                                the same if it is not already ‘error_deleting’ or ‘error’.</para>
                <para>If the status in model_update is ‘error_deleting’ or ‘error’, the
                                manager will raise an exception and the status of group_snapshot will
                                be set to ‘error’ in the db. If snapshots_model_update is not returned
                                by the driver, the manager will set the status of every snapshot to
                                ‘error’ in the except block.</para>
                <para>If the driver raises an exception during the operation, it will be
                                caught by the try-except block in the manager and the statuses of
                                group_snapshot and all snapshots will be set to ‘error’.</para>
                <para>For a successful operation, the driver can either build the
                                model_update and snapshots_model_update and return them or
                                return None, None. The statuses of group_snapshot and all snapshots
                                will be set to ‘deleted’ after the manager deletes them from db.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Deletes a volume.</para>
                <para>If volume_type extra specs includes ‘replication: &lt;is&gt; True’
                                then the driver needs to delete the volume replica too.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Callback for volume detached.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Disables replication for a group and volumes in the group.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Any initialization the volume driver does while starting.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Enables replication for a group and volumes in the group.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Synchronously recreates an export for a volume.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Like failover but for a host that is clustered.</para>
                <para>Most of the time this will be the exact same behavior as failover_host,
                                so if it’s not overwritten, it is assumed to be the case.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>This method is called after failover for clustered backends.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Failover a backend to a secondary replication target.</para>
                <para>Instructs a replication capable/configured backend to failover
                                to one of it’s secondary replication targets. host=None is
                                an acceptable input, and leaves it to the driver to failover
                                to the only configured target, or to choose a target on it’s
                                own. All of the hosts volumes will be passed on to the driver
                                in order for it to determine the replicated volumes on the host,
                                if needed.</para>
                <para>Response is a tuple, including the new target backend_id
                                AND a lit of dictionaries with volume_id and updates.
                                Key things to consider (attaching failed-over volumes):
                                - provider_location
                                - provider_auth
                                - provider_id
                                - replication_status</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Fails over replication for a group and volumes in the group.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Notify the backend that it’s frozen.</para>
                <para>We use set to prohibit the creation of any new resources
                                on the backend, or any modifications to existing items on
                                a backend.  We set/enforce this by not allowing scheduling
                                of new volumes to the specified backend, and checking at the
                                api for modifications to resources and failing.</para>
                <para>In most cases the driver may not need to do anything, but
                                this provides a handle if they need it.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Get a backup device from an existing volume.</para>
                <para>The function returns a volume or snapshot to backup service,
                                and then backup service attaches the device and does backup.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Get the default filter_function string.</para>
                <para>Each driver could overwrite the method to return a well-known
                                default string if it is available.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Get the default goodness_function string.</para>
                <para>Each driver could overwrite the method to return a well-known
                                default string if it is available.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Get filter_function string.</para>
                <para>Returns either the string from the driver instance or global section
                                in cinder.conf. If nothing is specified in cinder.conf, then try to
                                find the default filter_function. When None is returned the scheduler
                                will always pass the driver instance.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Get good_function string.</para>
                <para>Returns either the string from the driver instance or global section
                                in cinder.conf. If nothing is specified in cinder.conf, then try to
                                find the default goodness_function. When None is returned the scheduler
                                will give the lowest score to the driver instance.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Return pool name where volume reside on.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Return prefixed property name</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Returns error info for replicated groups and its volumes.</para>
                <para>if error happens. For example, a dict of a group can be as follows:</para>
                <screen>{'group_id':xxxx,'replication_status':fields.ReplicationStatus.ERROR}</screen>
                <para>if error happens. For example, a dict of a volume can be as follows:</para>
                <screen>{'volume_id':xxxx,'replication_status':fields.ReplicationStatus.ERROR}</screen>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Old replication update method, deprecate.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Get the current version of this driver.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Return the current state of the volume service.</para>
                <para>If ‘refresh’ is True, run the update first.</para>
                <para>For replication the following state should be reported:
                                replication = True (None or false disables replication)</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Obtain backend volume stats and capabilities list.</para>
                <para>This stores a dictionary which is consisted of two parts.
                                First part includes static backend capabilities which are
                                obtained by get_volume_stats(). Second part is properties,
                                which includes parameters correspond to extra specs.
                                This properties part is consisted of cinder standard
                                capabilities and vendor unique properties.</para>
                <para>Using this capabilities list, operator can manage/configure
                                backend using key/value from capabilities without specific
                                knowledge of backend.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Allow connection to connector and return connection info.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Allow connection to connector and return connection info.</para>
                <para>The “initiator_updates” field must be a dictionary containing a
                                “set_values” and/or “remove_values” field. The “set_values” field must
                                be a dictionary of key-value pairs to be set/updated in the db. The
                                “remove_values” field must be a list of keys, previously set with
                                “set_values”, that will be deleted from the db.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Manage exiting stub.</para>
                <para>This is for drivers that don’t implement manage_existing().</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Migrate volume stub.</para>
                <para>This is for drivers that don’t implement an enhanced version
                                of this operation.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Removes an export for a volume.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Removes an export for a snapshot.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Determine if driver is running in Secure File Operations mode.</para>
                <para>The Cinder Volume driver needs to query if this driver is running
                                in a secure file operations mode. By default, it is False: any driver
                                that does support secure file operations should override this method.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Check if driver class supports replication features.</para>
                <variablelist>
                  <varlistentry>
                    <term>Feature is a string that must be one of:</term>
                    <listitem>
                      <itemizedlist>
                        <listitem>
                          <para>v2.1</para>
                        </listitem>
                        <listitem>
                          <para>a/a</para>
                        </listitem>
                      </itemizedlist>
                    </listitem>
                  </varlistentry>
                </variablelist>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Disallow connection from connector.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Disallow connection from connector.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Notify the backend that it’s unfrozen/thawed.</para>
                <para>Returns the backend to a normal state after a freeze
                                operation.</para>
                <para>In most cases the driver may not need to do anything, but
                                this provides a handle if they need it.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Unmanage stub.</para>
                <para>This is for drivers that don’t implement unmanage().</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Updates a group.</para>
                <para>model_update is a dictionary that the driver wants the manager
                                to update upon a successful return. If None is returned, the manager
                                will set the status to ‘available’.</para>
                <para>add_volumes_update and remove_volumes_update are lists of dictionaries
                                that the driver wants the manager to update upon a successful return.
                                Note that each entry requires a {‘id’: xxx} so that the correct
                                volume entry can be updated. If None is returned, the volume will
                                remain its original status. Also note that you cannot directly
                                assign add_volumes to add_volumes_update as add_volumes is a list of
                                volume objects and cannot be used for db update directly. Same with
                                remove_volumes.</para>
                <para>If the driver throws an exception, the status of the group as well as
                                those of the volumes to be added/removed will be set to ‘error’.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Return model update for migrated volume.</para>
                <para>Each driver implementing this method needs to be responsible for the
                                values of _name_id and provider_location. If None is returned or either
                                key is not set, it means the volume table does not need to change the
                                value(s) for the key(s).
                                The return format is {“_name_id”: value, “provider_location”: value}.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Get provider info updates from driver.</para>
                <para>where volume updates {‘id’: uuid, provider_id: &lt;provider-id&gt;}
                                and snapshot updates {‘id’: uuid, provider_id: &lt;provider-id&gt;}</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Fail if connector doesn’t contain all the data needed by driver.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry>
        <term>
          <literal/>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Create a volume efficiently from an existing image.</para>
                <para>image_location is a string whose format depends on the
                                image service backend in use. The driver should use it
                                to determine whether cloning is possible.</para>
                <para>image_id is a string which represents id of the image.
                                It can be used by the driver to introspect internal
                                stores or registry to do an efficient image clone.</para>
                <para>image_meta is a dictionary that includes ‘disk_format’ (e.g.
                                raw, qcow2) and other image attributes that allow drivers to
                                decide whether they can clone the image without first requiring
                                conversion.</para>
                <para>image_service is the reference of the image_service to use.
                                Note that this is needed to be passed here for drivers that
                                will want to fetch images from the image service directly.</para>
                <para>Returns a dict of volume properties eg. provider_location,
                                boolean indicating whether cloning occurred</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry>
        <term>
          <literal/>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>This class has been deprecated and should not be inherited.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry>
        <term>
          <literal/>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>This class has been deprecated and should not be inherited.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry>
        <term>
          <literal/>
        </term>
        <listitem>
          <para>Bases: <xref linkend="cinder.volume.driver.VolumeDriver"/></para>
          <para>Executes commands relating to Fibre Channel volumes.</para>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Get volume stats.</para>
                <para>If ‘refresh’ is True, run update the stats first.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Initializes the connection and returns connection info.</para>
                <para>The  driver returns a driver_volume_type of ‘fibre_channel’.
                                The target_wwn can be a single entry or a list of wwns that
                                correspond to the list of remote wwn(s) that will export the volume.
                                Example return values:</para>
                <screen language="default">{
    'driver_volume_type': 'fibre_channel',
    'data': {
        'target_discovered': True,
        'target_lun': 1,
        'target_wwn': '1234567890123',
        'discard': False
    }
}</screen>
                <para>or</para>
                <screen language="default"> {
    'driver_volume_type': 'fibre_channel',
    'data': {
        'target_discovered': True,
        'target_lun': 1,
        'target_wwn': ['1234567890123', '0987654321321'],
        'discard': False
    }
}</screen>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Fail if connector doesn’t contain all the data needed by driver.</para>
                <para>Do a check on the connector and ensure that it has wwnns, wwpns.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Test for non-empty setting in connector.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry>
        <term>
          <literal/>
        </term>
        <listitem>
          <para>Bases: <xref linkend="cinder.volume.driver.VolumeDriver"/></para>
          <para>Executes commands relating to ISCSI volumes.</para>
          <para>We make use of model provider properties as follows:</para>
          <variablelist>
            <varlistentry>
              <term>
                <literal>provider_location</literal>
              </term>
              <listitem>
                <para>if present, contains the iSCSI target information in the same
                                    format as an ietadm discovery
                                    i.e. ‘&lt;ip&gt;:&lt;port&gt;,&lt;portal&gt; &lt;target IQN&gt;’</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>provider_auth</literal>
              </term>
              <listitem>
                <para>if present, contains a space-separated triple:
                                    ‘&lt;auth method&gt; &lt;auth username&gt; &lt;auth password&gt;’.
                                    <literal>CHAP</literal> is the only auth_method in use at the moment.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Get volume stats.</para>
                <para>If ‘refresh’ is True, run update the stats first.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Initializes the connection and returns connection info.</para>
                <para>The iscsi driver returns a driver_volume_type of ‘iscsi’.
                                The format of the driver data is defined in _get_iscsi_properties.
                                Example return value:</para>
                <screen>{
    'driver_volume_type': 'iscsi'
    'data': {
        'target_discovered': True,
        'target_iqn': 'iqn.2010-10.org.openstack:volume-00000001',
        'target_portal': '127.0.0.0.1:3260',
        'volume_id': 1,
        'discard': False,
    }
}</screen>
                <para>If the backend driver supports multiple connections for multipath and
                                for single path with failover, “target_portals”, “target_iqns”,
                                “target_luns” are also populated:</para>
                <screen>{
    'driver_volume_type': 'iscsi'
    'data': {
        'target_discovered': False,
        'target_iqn': 'iqn.2010-10.org.openstack:volume1',
        'target_iqns': ['iqn.2010-10.org.openstack:volume1',
                        'iqn.2010-10.org.openstack:volume1-2'],
        'target_portal': '10.0.0.1:3260',
        'target_portals': ['10.0.0.1:3260', '10.0.1.1:3260']
        'target_lun': 1,
        'target_luns': [1, 1],
        'volume_id': 1,
        'discard': False,
    }
}</screen>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry>
        <term>
          <literal/>
        </term>
        <listitem>
          <para>Bases: <xref linkend="cinder.volume.driver.ISCSIDriver"/></para>
          <para>Executes commands relating to ISER volumes.</para>
          <para>We make use of model provider properties as follows:</para>
          <variablelist>
            <varlistentry>
              <term>
                <literal>provider_location</literal>
              </term>
              <listitem>
                <para>if present, contains the iSER target information in the same
                                    format as an ietadm discovery
                                    i.e. ‘&lt;ip&gt;:&lt;port&gt;,&lt;portal&gt; &lt;target IQN&gt;’</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <literal>provider_auth</literal>
              </term>
              <listitem>
                <para>if present, contains a space-separated triple:
                                    ‘&lt;auth method&gt; &lt;auth username&gt; &lt;auth password&gt;’.
                                    <literal>CHAP</literal> is the only auth_method in use at the moment.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Initializes the connection and returns connection info.</para>
                <para>The iser driver returns a driver_volume_type of ‘iser’.
                                The format of the driver data is defined in _get_iser_properties.
                                Example return value:</para>
                <screen language="default">{
    'driver_volume_type': 'iser',
    'data': {
        'target_discovered': True,
        'target_iqn':
        'iqn.2010-10.org.iser.openstack:volume-00000001',
        'target_portal': '127.0.0.0.1:3260',
        'volume_id': 1
    }
}</screen>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry>
        <term>
          <literal/>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>This class has been deprecated and should not be inherited.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry>
        <term>
          <literal/>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>List snapshots on the backend available for management by Cinder.</para>
                <para>Returns a list of dictionaries, each specifying a snapshot in the host,
                                with the following keys:
                                - reference (dictionary): The reference for a snapshot, which can be
                                passed to “manage_existing_snapshot”.
                                - size (int): The size of the snapshot according to the storage
                                backend, rounded up to the nearest GB.
                                - safe_to_manage (boolean): Whether or not this snapshot is safe to
                                manage according to the storage backend. For example, is the snapshot
                                in use or invalid for any reason.
                                - reason_not_safe (string): If safe_to_manage is False, the reason why.
                                - cinder_id (string): If already managed, provide the Cinder ID.
                                - extra_info (string): Any extra information to return to the user
                                - source_reference (string): Similar to “reference”, but for the
                                snapshot’s source volume.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Brings an existing backend storage object under Cinder management.</para>
                <para>existing_ref is passed straight through from the API request’s
                                manage_existing_ref value, and it is up to the driver how this should
                                be interpreted.  It should be sufficient to identify a storage object
                                that the driver should somehow associate with the newly-created cinder
                                snapshot structure.</para>
                <para>There are two ways to do this:</para>
                <procedure>
                  <step>
                    <para>Rename the backend storage object so that it matches the
                                        snapshot[‘name’] which is how drivers traditionally map between a
                                        cinder snapshot and the associated backend storage object.</para>
                  </step>
                  <step>
                    <para>Place some metadata on the snapshot, or somewhere in the backend,
                                        that allows other driver requests (e.g. delete) to locate the
                                        backend storage object when required.</para>
                  </step>
                </procedure>
                <para>If the existing_ref doesn’t make sense, or doesn’t refer to an existing
                                backend storage object, raise a ManageExistingInvalidReference
                                exception.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Return size of snapshot to be managed by manage_existing.</para>
                <para>When calculating the size, round up to the next GB.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Removes the specified snapshot from Cinder management.</para>
                <para>Does not delete the underlying backend storage object.</para>
                <para>For most drivers, this will not need to do anything. However, some
                                drivers might use this call as an opportunity to clean up any
                                Cinder-specific configuration that they have associated with the
                                backend storage object.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry>
        <term>
          <literal/>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>List volumes on the backend available for management by Cinder.</para>
                <para>Returns a list of dictionaries, each specifying a volume in the host,
                                with the following keys:
                                - reference (dictionary): The reference for a volume, which can be
                                passed to “manage_existing”.
                                - size (int): The size of the volume according to the storage
                                backend, rounded up to the nearest GB.
                                - safe_to_manage (boolean): Whether or not this volume is safe to
                                manage according to the storage backend. For example, is the volume
                                in use or invalid for any reason.
                                - reason_not_safe (string): If safe_to_manage is False, the reason why.
                                - cinder_id (string): If already managed, provide the Cinder ID.
                                - extra_info (string): Any extra information to return to the user</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Brings an existing backend storage object under Cinder management.</para>
                <para>existing_ref is passed straight through from the API request’s
                                manage_existing_ref value, and it is up to the driver how this should
                                be interpreted.  It should be sufficient to identify a storage object
                                that the driver should somehow associate with the newly-created cinder
                                volume structure.</para>
                <para>There are two ways to do this:</para>
                <procedure>
                  <step>
                    <para>Rename the backend storage object so that it matches the,
                                        volume[‘name’] which is how drivers traditionally map between a
                                        cinder volume and the associated backend storage object.</para>
                  </step>
                  <step>
                    <para>Place some metadata on the volume, or somewhere in the backend, that
                                        allows other driver requests (e.g. delete, clone, attach, detach…)
                                        to locate the backend storage object when required.</para>
                  </step>
                </procedure>
                <para>If the existing_ref doesn’t make sense, or doesn’t refer to an existing
                                backend storage object, raise a ManageExistingInvalidReference
                                exception.</para>
                <para>The volume may have a volume_type, and the driver can inspect that and
                                compare against the properties of the referenced backend storage
                                object.  If they are incompatible, raise a
                                ManageExistingVolumeTypeMismatch, specifying a reason for the failure.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Return size of volume to be managed by manage_existing.</para>
                <para>When calculating the size, round up to the next GB.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Removes the specified volume from Cinder management.</para>
                <para>Does not delete the underlying backend storage object.</para>
                <para>For most drivers, this will not need to do anything.  However, some
                                drivers might use this call as an opportunity to clean up any
                                Cinder-specific configuration that they have associated with the
                                backend storage object.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry>
        <term>
          <literal/>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Migrate the volume to the specified host.</para>
                <para>Returns a boolean indicating whether the migration occurred, as well as
                                model_update.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry>
        <term>
          <literal/>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>Proxy Volume Driver to mark proxy drivers</para>
          <para>If a driver uses a proxy class (e.g. by using __setattr__ and
                        __getattr__) without directly inheriting from base volume driver this
                        class can help marking them and retrieve the actual used driver object.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry>
        <term>
          <literal/>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>This class has been deprecated and should not be inherited.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry>
        <term>
          <literal/>
        </term>
        <listitem>
          <para>Bases: <literal>object</literal></para>
          <para>This class has been deprecated and should not be inherited.</para>
        </listitem>
      </varlistentry>
    </variablelist>
    <variablelist>
      <varlistentry>
        <term>
          <literal/>
        </term>
        <listitem>
          <para>Bases: <xref linkend="cinder.volume.driver.ManageableVD"/>, <xref linkend="cinder.volume.driver.CloneableImageVD"/>, <xref linkend="cinder.volume.driver.ManageableSnapshotsVD"/>, <xref linkend="cinder.volume.driver.MigrateVD"/>, <xref linkend="cinder.volume.driver.BaseVD"/></para>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Creates a cgsnapshot.</para>
                <para>param snapshots is retrieved directly from the db. It is a list of
                                cinder.db.sqlalchemy.models.Snapshot to be precise. It cannot be
                                assigned to snapshots_model_update. snapshots_model_update is a list
                                of dictionaries. It has to be built by the driver. An entry will be
                                in this format: {‘id’: xxx, ‘status’: xxx, ……}. model_update
                                will be in this format: {‘status’: xxx, ……}.</para>
                <para>The driver should populate snapshots_model_update and model_update
                                and return them.</para>
                <para>The manager will check snapshots_model_update and update db accordingly
                                for each snapshot. If the driver successfully deleted some snapshots
                                but failed to delete others, it should set statuses of the snapshots
                                accordingly so that the manager can update db correctly.</para>
                <para>If the status in any entry of snapshots_model_update is ‘error’, the
                                status in model_update will be set to the same if it is not already
                                ‘error’.</para>
                <para>If the status in model_update is ‘error’, the manager will raise an
                                exception and the status of cgsnapshot will be set to ‘error’ in the
                                db. If snapshots_model_update is not returned by the driver, the
                                manager will set the status of every snapshot to ‘error’ in the except
                                block.</para>
                <para>If the driver raises an exception during the operation, it will be
                                caught by the try-except block in the manager and the statuses of
                                cgsnapshot and all snapshots will be set to ‘error’.</para>
                <para>For a successful operation, the driver can either build the
                                model_update and snapshots_model_update and return them or
                                return None, None. The statuses of cgsnapshot and all snapshots
                                will be set to ‘available’ at the end of the manager function.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Creates a consistencygroup.</para>
                <para>model_update will be in this format: {‘status’: xxx, ……}.</para>
                <para>If the status in model_update is ‘error’, the manager will throw
                                an exception and it will be caught in the try-except block in the
                                manager. If the driver throws an exception, the manager will also
                                catch it in the try-except block. The group status in the db will
                                be changed to ‘error’.</para>
                <para>For a successful operation, the driver can either build the
                                model_update and return it or return None. The group status will
                                be set to ‘available’.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Creates a consistencygroup from source.</para>
                <para>The source can be cgsnapshot or a source cg.</para>
                <para>param volumes is retrieved directly from the db. It is a list of
                                cinder.db.sqlalchemy.models.Volume to be precise. It cannot be
                                assigned to volumes_model_update. volumes_model_update is a list of
                                dictionaries. It has to be built by the driver. An entry will be
                                in this format: {‘id’: xxx, ‘status’: xxx, ……}. model_update
                                will be in this format: {‘status’: xxx, ……}.</para>
                <para>To be consistent with other volume operations, the manager will
                                assume the operation is successful if no exception is thrown by
                                the driver. For a successful operation, the driver can either build
                                the model_update and volumes_model_update and return them or
                                return None, None.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Creates a snapshot.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Creates a volume from a snapshot.</para>
                <para>If volume_type extra specs includes ‘replication: &lt;is&gt; True’
                                the driver needs to create a volume replica (secondary),
                                and setup replication between the newly created volume and
                                the secondary volume.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Deletes a cgsnapshot.</para>
                <para>param snapshots is retrieved directly from the db. It is a list of
                                cinder.db.sqlalchemy.models.Snapshot to be precise. It cannot be
                                assigned to snapshots_model_update. snapshots_model_update is a list
                                of dictionaries. It has to be built by the driver. An entry will be
                                in this format: {‘id’: xxx, ‘status’: xxx, ……}. model_update
                                will be in this format: {‘status’: xxx, ……}.</para>
                <para>The driver should populate snapshots_model_update and model_update
                                and return them.</para>
                <para>The manager will check snapshots_model_update and update db accordingly
                                for each snapshot. If the driver successfully deleted some snapshots
                                but failed to delete others, it should set statuses of the snapshots
                                accordingly so that the manager can update db correctly.</para>
                <para>If the status in any entry of snapshots_model_update is
                                ‘error_deleting’ or ‘error’, the status in model_update will be set to
                                the same if it is not already ‘error_deleting’ or ‘error’.</para>
                <para>If the status in model_update is ‘error_deleting’ or ‘error’, the
                                manager will raise an exception and the status of cgsnapshot will be
                                set to ‘error’ in the db. If snapshots_model_update is not returned by
                                the driver, the manager will set the status of every snapshot to
                                ‘error’ in the except block.</para>
                <para>If the driver raises an exception during the operation, it will be
                                caught by the try-except block in the manager and the statuses of
                                cgsnapshot and all snapshots will be set to ‘error’.</para>
                <para>For a successful operation, the driver can either build the
                                model_update and snapshots_model_update and return them or
                                return None, None. The statuses of cgsnapshot and all snapshots
                                will be set to ‘deleted’ after the manager deletes them from db.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Deletes a consistency group.</para>
                <para>param volumes is retrieved directly from the db. It is a list of
                                cinder.db.sqlalchemy.models.Volume to be precise. It cannot be
                                assigned to volumes_model_update. volumes_model_update is a list of
                                dictionaries. It has to be built by the driver. An entry will be
                                in this format: {‘id’: xxx, ‘status’: xxx, ……}. model_update
                                will be in this format: {‘status’: xxx, ……}.</para>
                <para>The driver should populate volumes_model_update and model_update
                                and return them.</para>
                <para>The manager will check volumes_model_update and update db accordingly
                                for each volume. If the driver successfully deleted some volumes
                                but failed to delete others, it should set statuses of the volumes
                                accordingly so that the manager can update db correctly.</para>
                <para>If the status in any entry of volumes_model_update is ‘error_deleting’
                                or ‘error’, the status in model_update will be set to the same if it
                                is not already ‘error_deleting’ or ‘error’.</para>
                <para>If the status in model_update is ‘error_deleting’ or ‘error’, the
                                manager will raise an exception and the status of the group will be
                                set to ‘error’ in the db. If volumes_model_update is not returned by
                                the driver, the manager will set the status of every volume in the
                                group to ‘error’ in the except block.</para>
                <para>If the driver raises an exception during the operation, it will be
                                caught by the try-except block in the manager. The statuses of the
                                group and all volumes in it will be set to ‘error’.</para>
                <para>For a successful operation, the driver can either build the
                                model_update and volumes_model_update and return them or
                                return None, None. The statuses of the group and all volumes
                                will be set to ‘deleted’ after the manager deletes them from db.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Deletes a snapshot.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Return pool name where volume reside on.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Allow connection from connector for a snapshot.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Revert volume to snapshot.</para>
                <para>Note: the revert process should not change the volume’s
                                current size, that means if the driver shrank
                                the volume during the process, it should extend the
                                volume internally.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Disallow connection from connector</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Disallow connection from connector for a snapshot.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para/>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Unmanage the specified snapshot from Cinder management.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
              <term>
                <property/>
              </term>
              <listitem>
                <para>Updates a consistency group.</para>
                <para>model_update is a dictionary that the driver wants the manager
                                to update upon a successful return. If None is returned, the manager
                                will set the status to ‘available’.</para>
                <para>add_volumes_update and remove_volumes_update are lists of dictionaries
                                that the driver wants the manager to update upon a successful return.
                                Note that each entry requires a {‘id’: xxx} so that the correct
                                volume entry can be updated. If None is returned, the volume will
                                remain its original status. Also note that you cannot directly
                                assign add_volumes to add_volumes_update as add_volumes is a list of
                                cinder.db.sqlalchemy.models.Volume objects and cannot be used for
                                db update directly. Same with remove_volumes.</para>
                <para>If the driver throws an exception, the status of the group as well as
                                those of the volumes to be added/removed will be set to ‘error’.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
    </variablelist>
  </section>
  <section>
    <title>Tests</title>
    <section>
      <title>The <literal>cinder.tests.unit.volume</literal> Module</title>
      <variablelist>
        <varlistentry>
          <term>
            <literal/>
          </term>
          <listitem>
            <para>Bases: <xref linkend="cinder.test.TestCase"/></para>
            <para>Test Case for volumes.</para>
            <variablelist>
              <varlistentry>
                <term>
                  <property/>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry>
                <term>
                  <property/>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
            <variablelist>
              <varlistentry>
                <term>
                  <property/>
                </term>
                <listitem>
                  <para/>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>
  <section>
    <title>Old Docs</title>
    <para>Cinder uses iSCSI to export storage volumes from multiple storage nodes. These iSCSI exports are attached (using libvirt) directly to running instances.</para>
    <para>Cinder volumes are exported over the primary system VLAN (usually VLAN 1), and not over individual VLANs.</para>
    <para>The underlying volumes by default are LVM logical volumes, created on demand within a single large volume group.</para>
  </section>
</section>
