<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1" xml:id="topics-javascript-testing">
  <title>JavaScript Testing</title>
  <para>There are multiple components in our JavaScript testing framework:</para>
  <itemizedlist>
    <listitem>
      <para><link xlink:href="https://jasmine.github.io/2.3/introduction.html">Jasmine</link> is our testing framework, so this defines the syntax and file
                    structure we use to test our JavaScript.</para>
    </listitem>
    <listitem>
      <para><link xlink:href="https://karma-runner.github.io/">Karma</link> is our test runner. Amongst other things, this lets us run the
                    tests against multiple browsers and generate test coverage reports.
                    Alternatively, tests can be run inside the browser with the Jasmine spec
                    runner.</para>
    </listitem>
    <listitem>
      <para><link xlink:href="http://phantomjs.org/">PhantomJS</link> provides a headless WebKit (the browser engine). This gives us
                    native support for many web features without relying on specific browsers
                    being installed.</para>
    </listitem>
    <listitem>
      <para><link xlink:href="http://eslint.org/">ESLint</link> is a pluggable code linting utility. This will catch small errors
                    and inconsistencies in your JS, which may lead to bigger issues later on.
                    See <xref linkend="js-code-style"/> for more detail.</para>
    </listitem>
  </itemizedlist>
  <para>Jasmine uses specs (<literal>.spec.js</literal>) which are kept with the JavaScript files
            that they are testing. See the <xref linkend="js-file-structure"/> section or the
            <xref linkend="examples"/> below for more detail on this.</para>
  <section>
    <title>Running Tests</title>
    <para>Tests can be run in two ways:</para>
    <procedure>
      <step>
        <para>Open &lt;dev_server_ip:port&gt;/jasmine in a browser. The development server can be
                        run with <literal>tox -e runserver</literal> from the horizon root directory.</para>
      </step>
      <step>
        <para><literal>tox -e npm</literal> from the horizon root directory. This runs Karma,
                        so it will run all the tests against PhantomJS and generate coverage
                        reports.</para>
      </step>
    </procedure>
    <para>The code linting job can be run with <literal>tox -e npm -- lint</literal>, or
                <literal>tox -e npm -- lintq</literal> to show errors, but not warnings.</para>
    <para>To decipher where tests are failing it may be useful to use Jasmine in the
                browser to run individual tests to see where the tests are specifically
                breaking. To do this, navigate to your local horizon in the browser and add
                ‘/jasmine’ to the end of the url. e.g: ‘<link xlink:href="http://localhost:8000/jasmine"/>’. Once
                you have the jasmine report you may click on the title of an individual test to
                re-run just that test. From here, you can also use chrome dev tools or similar
                to set breakpoints in the code by accessing the ‘Sources’ tab and clicking on
                lines of code where you wish to break the code. This will then show you the
                exact places where the code breaks.</para>
    <section>
      <title>Coverage Reports</title>
      <para>Our Karma setup includes a plugin to generate test coverage reports. When
                    developing, be sure to check the coverage reports on the master branch and
                    compare your development branch; this will help identify missing tests.</para>
      <para>To generate coverage reports, run <literal>tox -e npm</literal>. The coverage reports can be
                    found at <literal>cover/horizon/</literal> (framework tests) and <literal>cover/openstack_dashboard/</literal>
                    (dashboard tests). Load <literal>&lt;browser&gt;/index.html</literal> in a browser to view the
                    reports.</para>
    </section>
  </section>
  <section>
    <title>Writing Tests</title>
    <para>Jasmine uses suites and specs:</para>
    <itemizedlist>
      <listitem>
        <para>Suites begin with a call to <literal>describe</literal>, which takes two parameters; a
                        string and a function. The string is a name or title for the spec suite,
                        whilst the function is a block that implements the suite.</para>
      </listitem>
      <listitem>
        <para>Specs begin with a call to <literal>it</literal>, which also takes a string and a function
                        as parameters. The string is a name or title, whilst the function is a
                        block with one or more expectations (<literal>expect</literal>) that test the state of
                        the code. An expectation in Jasmine is an assertion that is either true or
                        false; every expectation in a spec must be true for the spec to pass.</para>
      </listitem>
    </itemizedlist>
    <para><literal>.spec.js</literal> files can be handled manually or automatically. To use the
                automatic file discovery add:</para>
    <screen>AUTO_DISCOVER_STATIC_FILES = True</screen>
    <para>to your enabled file. JS code for testing should use the extensions
                <literal>.mock.js</literal> and <literal>.spec.js</literal>.</para>
    <para>You can read more about the functionality in the
                <xref linkend="auto-discover-static-files"/> section of the settings documentation.</para>
    <para>To manually add specs, add the following array and relevant file paths to your
                enabled file:</para>
    <screen language="python">ADD_JS_SPEC_FILES = [
  ...
  'path_to/my_angular_code.spec.js',
  ...
]</screen>
  </section>
  <section xml:id="examples">
    <title>Examples</title>
    <note>
      <para>The code below is just for example purposes, and may not be current in
                    horizon. Ellipses (…) are used to represent code that has been
                    removed for the sake of brevity.</para>
    </note>
    <section>
      <title>Example 1 - A reusable component in the <emphasis role="bold">horizon</emphasis> directory</title>
      <para>File tree:</para>
      <screen language="none">horizon/static/framework/widgets/modal
├── modal.controller.js
├── modal.module.js
├── modal.service.js
└── modal.spec.js</screen>
      <para>Lines added to <literal>horizon/test/jasmine/jasmine_tests.py</literal>:</para>
      <screen language="python">class ServicesTests(test.JasmineTests):
  sources = [
    ...
    'framework/widgets/modal/modal.module.js',
    'framework/widgets/modal/modal.controller.js',
    'framework/widgets/modal/modal.service.js',
    ...
  ]

  specs = [
    ...
    'framework/widgets/modal/modal.spec.js',
    ...
  ]</screen>
      <para><literal>modal.spec.js</literal>:</para>
      <screen language="javascript">...

(function() {
  "use strict";

  describe('horizon.framework.widgets.modal module', function() {

    beforeEach(module('horizon.framework'));

    describe('simpleModalCtrl', function() {
      var scope;
      var modalInstance;
      var context;
      var ctrl;

      beforeEach(inject(function($controller) {
        scope = {};
        modalInstance = {
          close: function() {},
          dismiss: function() {}
        };
        context = { what: 'is it' };
        ctrl = $controller('simpleModalCtrl', {
               $scope: scope,
               $modalInstance: modalInstance,
               context: context
        });
      }));

      it('establishes a controller', function() {
        expect(ctrl).toBeDefined();
      });

      it('sets context on the scope', function() {
        expect(scope.context).toBeDefined();
        expect(scope.context).toEqual({ what: 'is it' });
      });

      it('sets action functions', function() {
        expect(scope.submit).toBeDefined();
        expect(scope.cancel).toBeDefined();
      });

      it('makes submit close the modal instance', function() {
        expect(scope.submit).toBeDefined();
        spyOn(modalInstance, 'close');
        scope.submit();
        expect(modalInstance.close.calls.count()).toBe(1);
      });

      it('makes cancel close the modal instance', function() {
        expect(scope.cancel).toBeDefined();
        spyOn(modalInstance, 'dismiss');
        scope.cancel();
        expect(modalInstance.dismiss).toHaveBeenCalledWith('cancel');
      });
    });

    ...

  });
})();</screen>
    </section>
    <section>
      <title>Example 2 - Panel-specific code in the <emphasis role="bold">openstack_dashboard</emphasis> directory</title>
      <para>File tree:</para>
      <screen language="none">openstack_dashboard/static/dashboard/launch-instance/network/
├── network.help.html
├── network.html
├── network.js
├── network.scss
└── network.spec.js</screen>
      <para>Lines added to <literal>openstack_dashboard/enabled/_10_project.py</literal>:</para>
      <screen language="python">LAUNCH_INST = 'dashboard/launch-instance/'

ADD_JS_FILES = [
  ...
  LAUNCH_INST + 'network/network.js',
  ...
]

ADD_JS_SPEC_FILES = [
  ...
  LAUNCH_INST + 'network/network.spec.js',
  ...
]</screen>
      <para><literal>network.spec.js</literal>:</para>
      <screen language="javascript">...

(function(){
  'use strict';

  describe('Launch Instance Network Step', function() {

    describe('LaunchInstanceNetworkCtrl', function() {
      var scope;
      var ctrl;

      beforeEach(module('horizon.dashboard.project.workflow.launch-instance'));

      beforeEach(inject(function($controller) {
        scope = {
          model: {
            newInstanceSpec: {networks: ['net-a']},
            networks: ['net-a', 'net-b']
          }
        };
        ctrl = $controller('LaunchInstanceNetworkCtrl', {$scope:scope});
      }));

      it('has correct network statuses', function() {
        expect(ctrl.networkStatuses).toBeDefined();
        expect(ctrl.networkStatuses.ACTIVE).toBeDefined();
        expect(ctrl.networkStatuses.DOWN).toBeDefined();
        expect(Object.keys(ctrl.networkStatuses).length).toBe(2);
      });

      it('has correct network admin states', function() {
        expect(ctrl.networkAdminStates).toBeDefined();
        expect(ctrl.networkAdminStates.UP).toBeDefined();
        expect(ctrl.networkAdminStates.DOWN).toBeDefined();
        expect(Object.keys(ctrl.networkStatuses).length).toBe(2);
      });

      it('defines a multiple-allocation table', function() {
        expect(ctrl.tableLimits).toBeDefined();
        expect(ctrl.tableLimits.maxAllocation).toBe(-1);
      });

      it('contains its own labels', function() {
        expect(ctrl.label).toBeDefined();
        expect(Object.keys(ctrl.label).length).toBeGreaterThan(0);
      });

      it('contains help text for the table', function() {
        expect(ctrl.tableHelpText).toBeDefined();
        expect(ctrl.tableHelpText.allocHelpText).toBeDefined();
        expect(ctrl.tableHelpText.availHelpText).toBeDefined();
      });

      it('uses scope to set table data', function() {
        expect(ctrl.tableDataMulti).toBeDefined();
        expect(ctrl.tableDataMulti.available).toEqual(['net-a', 'net-b']);
        expect(ctrl.tableDataMulti.allocated).toEqual(['net-a']);
        expect(ctrl.tableDataMulti.displayedAllocated).toEqual([]);
        expect(ctrl.tableDataMulti.displayedAvailable).toEqual([]);
      });
    });

    ...

  });
})();</screen>
    </section>
  </section>
</section>
