<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1" xml:id="topics-datatables">
  <title>DataTables Topic Guide</title>
  <para>Horizon provides the <xref linkend="module-horizon.tables"/> module to provide
            a convenient, reusable API for building data-driven displays and interfaces.
            The core components of this API fall into three categories: <literal>DataTables</literal>,
            <literal>Actions</literal>, and <literal>Class-based Views</literal>.</para>
  <formalpara>
    <title>See also</title>
    <para>For a detailed API information check out the <xref linkend="ref-datatables"/>.</para>
  </formalpara>
  <section xml:id="tables">
    <title>Tables</title>
    <para>The majority of interface in a dashboard-style interface ends up being
                tabular displays of the various resources the dashboard interacts with.
                The <xref linkend="horizon.tables.DataTable"/> class exists so you don’t have to
                reinvent the wheel each time.</para>
    <section>
      <title>Creating your own tables</title>
      <para>Creating a table is fairly simple:</para>
      <procedure>
        <step>
          <para>Create a subclass of <xref linkend="horizon.tables.DataTable"/>.</para>
        </step>
        <step>
          <para>Define columns on it using <xref linkend="horizon.tables.Column"/>.</para>
        </step>
        <step>
          <para>Create an inner <literal>Meta</literal> class to contain the special options for
                            this table.</para>
        </step>
        <step>
          <para>Define any actions for the table, and add them to
                            <xref linkend="horizon.tables.DataTableOptions.table_actions"/> or
                            <xref linkend="horizon.tables.DataTableOptions.row_actions"/>.</para>
        </step>
      </procedure>
      <para>Examples of this can be found in any of the <literal>tables.py</literal> modules included
                    in the reference modules under <literal>horizon.dashboards</literal>.</para>
    </section>
    <section>
      <title>Connecting a table to a view</title>
      <para>Once you’ve got your table set up the way you like it, the next step is to
                    wire it up to a view. To make this as easy as possible Horizon provides the
                    <xref linkend="horizon.tables.DataTableView"/> class-based view which can be subclassed
                    to display your table with just a couple lines of code. At its simplest, it
                    looks like this:</para>
      <screen>from horizon import tables
from .tables import MyTable


class MyTableView(tables.DataTableView):
    table_class = MyTable
    template_name = "my_app/my_table_view.html"

    def get_data(self):
        return my_api.objects.list()</screen>
      <para>In the template you would just need to include the following to render the
                    table:</para>
      <screen>{{ table.render }}</screen>
      <para>That’s it! Easy, right?</para>
    </section>
  </section>
  <section>
    <title>Actions</title>
    <para>Actions comprise any manipulations that might happen on the data in the table
                or the table itself. For example, this may be the standard object CRUD, linking
                to related views based on the object’s id, filtering the data in the table,
                or fetching updated data when appropriate.</para>
    <section>
      <title>When actions get run</title>
      <para>There are two points in the request-response cycle in which actions can
                    take place; prior to data being loaded into the table, and after the data
                    is loaded. When you’re using one of the pre-built class-based views for
                    working with your tables the pseudo-workflow looks like this:</para>
      <procedure>
        <step>
          <para>The request enters view.</para>
        </step>
        <step>
          <para>The table class is instantiated without data.</para>
        </step>
        <step>
          <para>Any “preemptive” actions are checked to see if they should run.</para>
        </step>
        <step>
          <para>Data is fetched and loaded into the table.</para>
        </step>
        <step>
          <para>All other actions are checked to see if they should run.</para>
        </step>
        <step>
          <para>If none of the actions have caused an early exit from the view,
                            the standard response from the view is returned (usually the
                            rendered table).</para>
        </step>
      </procedure>
      <para>The benefit of the multi-step table instantiation is that you can use
                    preemptive actions which don’t need access to the entire collection of data
                    to save yourself on processing overhead, API calls, etc.</para>
    </section>
    <section>
      <title>Basic actions</title>
      <para>At their simplest, there are three types of actions: actions which act on the
                    data in the table, actions which link to related resources, and actions that
                    alter which data is displayed. These correspond to
                    <xref linkend="horizon.tables.Action"/>, <xref linkend="horizon.tables.LinkAction"/>, and
                    <xref linkend="horizon.tables.FilterAction"/>.</para>
      <para>Writing your own actions generally starts with subclassing one of those
                    action classes and customizing the designated attributes and methods.</para>
    </section>
    <section>
      <title>Shortcut actions</title>
      <para>There are several common tasks for which Horizon provides pre-built shortcut
                    classes. These include <xref linkend="horizon.tables.BatchAction"/>, and
                    <xref linkend="horizon.tables.DeleteAction"/>. Each of these abstracts away nearly
                    all of the boilerplate associated with writing these types of actions and
                    provides consistent error handling, logging, and user-facing interaction.</para>
      <para>It is worth noting that <literal>BatchAction</literal> and <literal>DeleteAction</literal> are extensions
                    of the standard <literal>Action</literal> class. Some <literal>BatchAction</literal> or <literal>DeleteAction</literal>
                    classes may cause some unrecoverable results, like deleted images or
                    unrecoverable instances. It may be helpful to specify specific help_text to
                    explain the concern to the user, such as “Deleted images are not recoverable”.</para>
    </section>
    <section>
      <title>Preemptive actions</title>
      <para>Action classes which have their <xref linkend="horizon.tables.Action.preempt"/>
                    attribute set to <literal>True</literal> will be evaluated before any data is loaded into
                    the table. As such, you must be careful not to rely on any table methods that
                    require data, such as <xref linkend="horizon.tables.DataTable.get_object_display"/> or
                    <xref linkend="horizon.tables.DataTable.get_object_by_id"/>. The advantage of preemptive
                    actions is that you can avoid having to do all the processing, API calls, etc.
                    associated with loading data into the table for actions which don’t require
                    access to that information.</para>
    </section>
    <section>
      <title>Policy checks on actions</title>
      <para>The <xref linkend="horizon.tables.Action.policy_rules"/> attribute, when set, will
                    validate access to the action using the policy rules specified.  The attribute
                    is a list of scope/rule pairs.  Where the scope is the service type defining
                    the rule and the rule is a rule from the corresponding service policy.json
                    file.  The format of <xref linkend="horizon.tables.Action.policy_rules"/> looks like:</para>
      <screen>(("identity", "identity:get_user"),)</screen>
      <para>Multiple checks can be made for the same action by merely adding more tuples
                    to the list.  The policy check will use information stored in the session
                    about the user and the result of
                    <literal>get_policy_target()</literal> (which can be overridden in
                    the derived action class) to determine if the user
                    can execute the action.  If the user does not have access to the action, the
                    action is not added to the table.</para>
      <para>If <xref linkend="horizon.tables.Action.policy_rules"/> is not set, no policy checks
                    will be made to determine if the action should be visible and will be
                    displayed solely based on the result of
                    <literal>allowed()</literal>.</para>
      <para>For more information on policy based Role Based Access Control see
                    <xref linkend="topics-policy"/>.</para>
    </section>
  </section>
  <section>
    <title>Table Cell filters (decorators)</title>
    <para>DataTable displays lists of objects in rows and object attributes in cell.
                How should we proceed, if we want to decorate some column, e.g. if we have
                column <literal>memory</literal> which returns a number e.g. 1024, and we want to show
                something like 1024.00 GB inside table?</para>
    <section>
      <title>Decorator pattern</title>
      <para>The clear anti-pattern is defining the new attributes on object like
                    <literal>ram_float_format_2_gb</literal> or to tweak a DataTable in any way for displaying
                    purposes.</para>
      <para>The cleanest way is to use <literal>filters</literal>. Filters are decorators, following GOF
                    <literal>Decorator pattern</literal>. This way <literal>DataTable logic</literal> and <literal>displayed object
logic</literal> are correctly separated from <literal>presentation logic</literal> of the object
                    inside of the various tables. And therefore the filters are reusable in all
                    tables.</para>
    </section>
    <section>
      <title>Filter function</title>
      <para>Horizon DatablesTable takes a tuple of pointers to filter functions
                    or anonymous lambda functions. When displaying a <literal>Cell</literal>, <literal>DataTable</literal>
                    takes <literal>Column</literal> filter functions from left to right, using the returned value
                    of the previous function as a parameter of the following function. Then
                    displaying the returned value of the last filter function.</para>
      <para>A valid filter function takes one parameter and returns the decorated value.
                    So e.g. these are valid filter functions</para>
      <screen># Filter function.
def add_unit(v):
  return str(v) + " GB"

# Or filter lambda function.
lambda v: str(v) + " GB"

# This is also a valid definition of course, although for the change of the
# unit parameter, function has to be wrapped by lambda
# (e.g. floatformat function example below).
def add_unit(v, unit="GB"):
  return str(v) + " " + unit</screen>
    </section>
    <section>
      <title>Using filters in DataTable column</title>
      <para>DataTable takes tuple of filter functions, so e.g. this is valid decorating
                    of a value with float format and with unit</para>
      <screen>ram = tables.Column(
    "ram",
    verbose_name=_('Memory'),
    filters=(lambda v: floatformat(v, 2),
             add_unit))</screen>
      <para>It always takes tuple, so using only one filter would look like this</para>
      <screen>filters=(lambda v: floatformat(v, 2),)</screen>
      <para>The decorated parameter doesn’t have to be only a string or number, it can
                    be anything e.g. list or an object. So decorating of object, that has
                    attributes value and unit would look like this</para>
      <screen>ram = tables.Column(
        "ram",
        verbose_name=_('Memory'),
        filters=(lambda x: getattr(x, 'value', '') +
                 " " + getattr(x, 'unit', ''),))</screen>
    </section>
    <section>
      <title>Available filters</title>
      <para>There are a load of filters, that can be used, defined in django already:
                    <link xlink:href="https://github.com/django/django/blob/master/django/template/defaultfilters.py"/></para>
      <para>So it’s enough to just import and use them, e.g.</para>
      <screen>from django.template import defaultfilters as filters

# code omitted
filters=(filters.yesno, filters.capfirst)


from django.template.defaultfilters import timesince
from django.template.defaultfilters import title

# code omitted
filters=(parse_isotime, timesince)</screen>
    </section>
  </section>
  <section>
    <title>Inline editing</title>
    <para>Table cells can be easily upgraded with in-line editing. With use of
                django.form.Field, we are able to run validations of the field and correctly
                parse the data. The updating process is fully encapsulated into table
                functionality, communication with the server goes through AJAX in JSON format.
                The javascript wrapper for inline editing allows each table cell that has
                in-line editing available to:</para>
    <procedure>
      <step>
        <para>Refresh itself with new data from the server.</para>
      </step>
      <step>
        <para>Display in edit mode.</para>
      </step>
      <step>
        <para>Send changed data to server.</para>
      </step>
      <step>
        <para>Display validation errors.</para>
      </step>
    </procedure>
    <para>There are basically 3 things that need to be defined in the table in order
                to enable in-line editing.</para>
    <section>
      <title>Fetching the row data</title>
      <para>Defining an <literal>get_data</literal> method in a class inherited from <literal>tables.Row</literal>.
                    This method takes care of fetching the row data. This class has to be then
                    defined in the table Meta class as <literal>row_class = UpdateRow</literal>.</para>
      <para>Example:</para>
      <screen>class UpdateRow(tables.Row):
    # this method is also used for automatic update of the row
    ajax = True

    def get_data(self, request, project_id):
        # getting all data of all row cells
        project_info = api.keystone.tenant_get(request, project_id,
                                               admin=True)
        return project_info</screen>
    </section>
    <section>
      <title>Updating changed cell data (DEPRECATED)</title>
      <para>Define an <literal>update_cell</literal> method in the class inherited from
                    <literal>tables.UpdateAction</literal>. This method takes care of saving the data of the
                    table cell. There can be one class for every cell thanks to the
                    <literal>cell_name</literal> parameter. This class is then defined in tables column as
                    <literal>update_action=UpdateCell</literal>, so each column can have its own updating
                    method.</para>
      <para>Example:</para>
      <screen>class UpdateCell(tables.UpdateAction):
    def allowed(self, request, project, cell):
        # Determines whether given cell or row will be inline editable
        # for signed in user.
        return api.keystone.keystone_can_edit_project()

    def update_cell(self, request, project_id, cell_name, new_cell_value):
        # in-line update project info
        try:
            project_obj = datum
            # updating changed value by new value
            setattr(project_obj, cell_name, new_cell_value)

            # sending new attributes back to API
            api.keystone.tenant_update(
                request,
                project_id,
                name=project_obj.name,
                description=project_obj.description,
                enabled=project_obj.enabled)

        except Conflict:
            # Validation error for naming conflict, raised when user
            # choose the existing name. We will raise a
            # ValidationError, that will be sent back to the client
            # browser and shown inside of the table cell.
            message = _("This name is already taken.")
            raise ValidationError(message)
        except:
            # Other exception of the API just goes through standard
            # channel
            exceptions.handle(request, ignore=True)
            return False
        return True</screen>
    </section>
    <section>
      <title>Defining a form_field for each Column that we want to be in-line edited.</title>
      <para>Form field should be <literal>django.form.Field</literal> instance, so we can use django
                    validations and parsing of the values sent by POST (in example validation
                    <literal>required=True</literal> and correct parsing of the checkbox value from the POST
                    data).</para>
      <para>Form field can be also <literal>django.form.Widget</literal> class, if we need to just
                    display the form widget in the table and we don’t need Field functionality.</para>
      <para>Then connecting <literal>UpdateRow</literal> and <literal>UpdateCell</literal> classes to the table.</para>
      <para>Example:</para>
      <screen>class TenantsTable(tables.DataTable):
    # Adding html text input for inline editing, with required validation.
    # HTML form input will have a class attribute tenant-name-input, we
    # can define here any HTML attribute we need.
    name = tables.Column('name', verbose_name=_('Name'),
                         form_field=forms.CharField(required=True),
                         form_field_attributes={'class':'tenant-name-input'},
                         update_action=UpdateCell)

    # Adding html textarea without required validation.
    description = tables.Column(lambda obj: getattr(obj, 'description', None),
                                verbose_name=_('Description'),
                                form_field=forms.CharField(
                                    widget=forms.Textarea(),
                                    required=False),
                                update_action=UpdateCell)

    # Id will not be inline edited.
    id = tables.Column('id', verbose_name=_('Project ID'))

    # Adding html checkbox, that will be shown inside of the table cell with
    # label
    enabled = tables.Column('enabled', verbose_name=_('Enabled'), status=True,
                            form_field=forms.BooleanField(
                                label=_('Enabled'),
                                required=False),
                            update_action=UpdateCell)

    class Meta(object):
        name = "tenants"
        verbose_name = _("Projects")
        # Connection to UpdateRow, so table can fetch row data based on
        # their primary key.
        row_class = UpdateRow</screen>
    </section>
  </section>
</section>
