<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<section xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.1" xml:id="topics-policy">
  <title>Horizon Policy Enforcement (RBAC: Role Based Access Control)</title>
  <section>
    <title>Introduction</title>
    <para>Horizon’s policy enforcement builds on the oslo_policy engine.
                The basis of which is <literal>openstack_auth/policy.py</literal>.
                Services in OpenStack use the oslo policy engine to define policy rules
                to limit access to APIs based primarily on role grants and resource
                ownership.</para>
    <para>The Keystone v3 API provides an interface for creating/reading/updating
                policy files in the keystone database. However, at this time services
                do not load the policy files into Keystone. Thus, the implementation in
                Horizon is based on copies of policy.json files found in the service’s
                source code. The long-term goal is to read/utilize/update these policy
                files in Horizon.</para>
    <para>The service rules files are loaded into the policy engine to determine
                access rights to actions and service APIs.</para>
  </section>
  <section>
    <title>Horizon Settings</title>
    <para>There are a few settings that must be in place for the Horizon policy
                engine to work.</para>
    <section xml:id="policy-files-path">
      <title>
        <literal>POLICY_FILES_PATH</literal>
      </title>
      <para>Default:  <literal>os.path.join(ROOT_PATH, "conf")</literal></para>
      <para>Specifies where service based policy files are located.  These are used to
                    define the policy rules actions are verified against.  This value must contain
                    the files listed in <literal>POLICY_FILES</literal> or all policy checks will pass.</para>
      <note>
        <para>The path to deployment specific policy files can be specified in
                        <literal>local_settings.py</literal> to override the default location.</para>
      </note>
    </section>
    <section>
      <title>
        <literal>POLICY_FILES</literal>
      </title>
      <para>Default: <literal>{'identity': 'keystone_policy.json', 'compute': 'nova_policy.json'}</literal></para>
      <para>This should essentially be the mapping of the contents of <literal>POLICY_FILES_PATH</literal>
                    to service types.  When policy.json files are added to the directory
                    <literal>POLICY_FILES_PATH</literal>, they should be included here too. Without this mapping,
                    there is no way to map service types with policy rules, thus two policy.json
                    files containing a “default” rule would be ambiguous.</para>
      <note>
        <para>Deployment specific policy files can be specified in <literal>local_settings.py</literal>
                        to override the default policy files. It is imperative that these policy
                        files match those deployed in the target OpenStack installation. Otherwise,
                        the displayed actions and the allowed action will not match.</para>
      </note>
    </section>
    <section>
      <title>
        <literal>POLICY_CHECK_FUNCTION</literal>
      </title>
      <para>Default: <literal>policy.check</literal></para>
      <para>This value should not be changed, although removing it would be a means to
                    bypass all policy checks. Set it to <literal>None</literal> in <literal>local_settings.py</literal> to
                    do this.</para>
    </section>
  </section>
  <section>
    <title>How user’s roles are determined</title>
    <para>Each policy check uses information about the user stored on the request to
                determine the user’s roles. This information was extracted from the scoped
                token received from Keystone when authenticating.</para>
    <para>Entity ownership is also a valid role. To verify access to specific entities
                like a project, the target must be specified. See the section
                <xref linkend="rule-targets"/> later in this document.</para>
  </section>
  <section>
    <title>How to Utilize RBAC</title>
    <para>The primary way to add role based access control checks to panels is in the
                definition of table actions. When implementing a derived action class,
                setting the <xref linkend="horizon.tables.Action.policy_rules"/> attribute to valid
                policy rules will force a policy check before the
                <literal>horizon.tables.Action.allowed()</literal> method is called on the action. These
                rules are defined in the policy files pointed to by <literal>POLICY_PATH</literal> and
                <literal>POLICY_FILES</literal>. The rules are role based, where entity owner is also a
                role. The format for the <literal>policy_rules</literal> is a list of two item tuples. The
                first component of the tuple is the scope of the policy rule, this is the
                service type. This informs the policy engine which policy file to reference.
                The second component is the rule to enforce from the policy file specified by
                the scope. An example tuple is:</para>
    <screen>("identity", "identity:get_user")</screen>
    <para>x tuples can be added to enforce x rules.</para>
    <note>
      <para>If a rule specified is not found in the policy file, the policy check
                    will return False and the action will not be allowed.</para>
    </note>
    <para>The secondary way to add a role based check is to directly use the
                <literal>check()</literal> method.  The method takes a list
                of actions, same format as the <xref linkend="horizon.tables.Action.policy_rules"/>
                attribute detailed above; the current request object; and a dictionary of
                action targets. This is the method that <xref linkend="horizon.tables.Action"/> class
                utilizes.  Examples look like:</para>
    <screen>from openstack_dashboard import policy

allowed = policy.check((("identity", "identity:get_user"),
                       ("identity", "identity:get_project"),), request)

can_see = policy.check((("identity", "identity:get_user"),), request,
                       target={"domain_id": domainId})</screen>
    <note>
      <para>Any time multiple rules are specified in a single <literal>policy.check</literal> method
                    call, the result is the logical <literal>and</literal> of each rule check. So, if any
                    rule fails verification, the result is <literal>False</literal>.</para>
    </note>
    <para>The third way to add a role based check is in javascript files. Use the method
                ‘ifAllowed()’ in file ‘openstack_dashboard.static.app.core.policy.service.js’.
                The method takes a list of actions, similar format with the
                <xref linkend="horizon.tables.Action.policy_rules"/> attribute detailed above.
                An Example looks like:</para>
    <screen>angular
.module('horizon.dashboard.identity.users')
.controller('identityUsersTableController', identityUsersTableController);

identityUsersTableController.$inject = [
  'horizon.app.core.openstack-service-api.policy',
];

function identityUsersTableController(toast, gettext, policy, keystone) {
  var rules = [['identity', 'identity:list_users']];
  policy.ifAllowed({ rules: rules }).then(policySuccess, policyFailed);
}</screen>
    <para>The fourth way to add a role based check is in html files. Use angular
                directive ‘hz-if-policies’ in file
                ‘openstack_dashboard/static/app/core/cloud-services/hz-if-policies.directive.js’.
                Assume you have the following policy defined in your angular controller:</para>
    <screen>ctrl.policy = { rules: [["identity", "identity:update_user"]] }</screen>
    <para>Then in your HTML, use it like so:</para>
    <screen>&lt;div hz-if-policies='ctrl.policy'&gt;
  &lt;span&gt;I am visible if the policy is allowed!&lt;/span&gt;
&lt;/div&gt;</screen>
  </section>
  <section xml:id="rule-targets">
    <title>Rule Targets</title>
    <para>Some rules allow access if the user owns the entity. Policy check targets
                specify particular entities to check for user ownership. The target parameter
                to the <literal>check()</literal> method is a simple dictionary.
                For instance, the target for checking access a project looks like:</para>
    <screen>{"project_id": "0905760626534a74979afd3f4a9d67f1"}</screen>
    <para>If the value matches the <literal>project_id</literal> to which the user’s token is scoped,
                then access is allowed.</para>
    <para>When deriving the <xref linkend="horizon.tables.Action"/> class for use in a table, if
                a policy check is desired for a particular target, the implementer should
                override the <literal>horizon.tables.Action.get_policy_target()</literal> method. This
                allows a programmatic way to specify the target based on the current datum. The
                value returned should be the target dictionary.</para>
  </section>
</section>
